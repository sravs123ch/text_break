// import { $getRoot, $getSelection, $isRangeSelection } from "lexical";
// import { useEffect, useState } from "react";
// import { LexicalComposer } from "@lexical/react/LexicalComposer";
// import { HistoryPlugin } from "@lexical/react/LexicalHistoryPlugin";
// import { OnChangePlugin } from "@lexical/react/LexicalOnChangePlugin";
// import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
// import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
// import { MuiContentEditable, placeHolderSx } from "./styles";
// import { Box, Divider } from "@mui/material";
// import { lexicalEditorConfig } from "../../config/lexicalEditorConfig";
// import LexicalEditorTopBar from "../LexicalEditorTopBar";
// import TreeViewPlugin from "../CustomPlugins/TreeViewPlugin";
// import { ListPlugin } from "@lexical/react/LexicalListPlugin";
// import { LinkPlugin } from "@lexical/react/LexicalLinkPlugin";
// import ImagesPlugin from "../CustomPlugins/ImagePlugin";
// import FloatingTextFormatToolbarPlugin from "../CustomPlugins/FloatingTextFormatPlugin";
// import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
// import { Document, Packer, Paragraph, TextRun, ImageRun, AlignmentType, HeadingLevel, ExternalHyperlink, ShadingType, Table, TableRow, TableCell, WidthType, BorderStyle, TableLayoutType } from "docx";
// import { saveAs } from "file-saver";
// import ColorPlugin from "../CustomPlugins/ColorPlugin";
// import {
// 	$patchStyleText,
// 	$getSelectionStyleValueForProperty,
// } from "@lexical/selection";
// import { TablePlugin } from "@lexical/react/LexicalTablePlugin";
// import { $generateHtmlFromNodes } from "@lexical/html";


// function LexicalEditorWrapper(props) {
// 	// Function to handle DOCX download
// 	const handleDownloadDocx = async (editor) => {
// 		const editorState = editor.getEditorState();
// 		const blocks = [];

// 		// Capture editor-level default font family and size from DOM
// 		const readEditorDefaults = () => {
// 			const rootEl = document.querySelector('.ContentEditable__root');
// 			const cs = rootEl ? window.getComputedStyle(rootEl) : null;
// 			const fontFamily = cs?.fontFamily ? cs.fontFamily.split(',')[0].replace(/["']/g, '').trim() : undefined;
// 			const fontSizePx = cs?.fontSize ? parseFloat(cs.fontSize) : undefined;
// 			const fontSizeHalfPoints = Number.isFinite(fontSizePx) ? Math.round((fontSizePx * 0.75) * 2) : undefined; // px->pt->halfPoints
// 			return { fontFamily, fontSizeHalfPoints };
// 		};
// 		const editorDefaults = readEditorDefaults();

// 		// Measure table column widths directly from the DOM so DOCX matches the editor UI
// 		const measureTablesFromDOM = () => {
// 			const results = [];
// 			const rootEl = document.querySelector('.ContentEditable__root');
// 			if (!rootEl) return results;
// 			const tableEls = rootEl.querySelectorAll('table');
// 			tableEls.forEach((table) => {
// 				try {
// 					const firstRow = table.rows && table.rows[0];
// 					if (!firstRow) {
// 						results.push(null);
// 						return;
// 					}
// 					const colWidthsPx = [];
// 					for (let ci = 0; ci < firstRow.cells.length; ci++) {
// 						const rect = firstRow.cells[ci].getBoundingClientRect();
// 						colWidthsPx.push(Math.max(0, Math.round(rect.width)));
// 					}
// 					const totalPx = colWidthsPx.reduce((a, b) => a + b, 0);
// 					const pxToTwips = (px) => Math.max(0, Math.round(px * 15)); // 1px≈1/96in; 1in=1440 twips => 1440/96=15
// 					const colsTwips = colWidthsPx.map(pxToTwips);
// 					const totalTwips = pxToTwips(totalPx);
// 					results.push({ colsTwips, totalTwips });
// 				} catch (e) {
// 					results.push(null);
// 				}
// 			});
// 			return results;
// 		};

// 		const measuredTables = measureTablesFromDOM();
// 		let measuredTableIndex = 0;

// 		const parseStyleToObject = (styleString) => {
// 			const style = {};
// 			if (!styleString) return style;
// 			styleString.split(";").forEach((decl) => {
// 				const [prop, val] = decl.split(":");
// 				if (prop && val) {
// 					style[prop.trim()] = val.trim();
// 				}
// 			});
// 			return style;
// 		};

// 		const normalizeFontFamily = (family) => {
// 			if (!family) return undefined;
// 			const first = family.split(",")[0] || "";
// 			return first.replace(/["']/g, "").trim() || undefined;
// 		};

// 		const cssSizeToHalfPoints = (size) => {
// 			if (!size) return undefined;
// 			const s = String(size).trim().toLowerCase();
// 			if (s.endsWith("pt")) {
// 				const pt = parseFloat(s);
// 				return Number.isFinite(pt) ? Math.round(pt * 2) : undefined;
// 			}
// 			if (s.endsWith("px")) {
// 				const px = parseFloat(s);
// 				if (!Number.isFinite(px)) return undefined;
// 				const pt = px * 0.75; // 1pt = 1.333px => pt = px * 0.75
// 				return Math.round(pt * 2);
// 			}
// 			return undefined;
// 		};

// 		const colorToHexNoHash = (c) => {
// 			if (!c) return undefined;
// 			const m = c.trim();
// 			if (m.startsWith("#")) return m.slice(1).toUpperCase();
// 			return m.toUpperCase();
// 		};

// 		const cssLineHeightToDocxLine = (lineHeight, fallbackHalfPoints) => {
// 			if (!lineHeight) return undefined;
// 			const s = String(lineHeight).trim().toLowerCase();
// 			// Percent or numeric multiplier
// 			if (s.endsWith('%')) {
// 				const pct = parseFloat(s);
// 				if (Number.isFinite(pct)) return Math.round((pct / 100) * 240);
// 			}
// 			const num = parseFloat(s);
// 			if (Number.isFinite(num) && !s.endsWith('px') && !s.endsWith('pt')) {
// 				return Math.round(num * 240); // 1.0 -> 240
// 			}
// 			// Absolute px/pt: approximate by ratio against font size
// 			let linePt;
// 			if (s.endsWith('pt')) {
// 				linePt = parseFloat(s);
// 			} else if (s.endsWith('px')) {
// 				const px = parseFloat(s);
// 				linePt = Number.isFinite(px) ? px * 0.75 : undefined;
// 			}
// 			if (Number.isFinite(linePt)) {
// 				const fontPt = fallbackHalfPoints ? fallbackHalfPoints / 2 : 11; // default ~11pt
// 				const mult = linePt / fontPt;
// 				return Math.round(mult * 240);
// 			}
// 			return undefined;
// 		};

// 		editorState.read(() => {
// 			const root = $getRoot();

// 			const collectRunsFromNode = (node, linkMeta) => {
// 				const runs = [];
// 				const type = node.getType();
// 				if (type === "text") {
// 					const text = node.getTextContent();
// 					if (text && text.length > 0) {
// 						const styleObj = parseStyleToObject(node.getStyle && node.getStyle());
// 						const color = colorToHexNoHash(styleObj.color);
// 						const bgColor = colorToHexNoHash(styleObj["background-color"]);
// 						const fontFamily = normalizeFontFamily(styleObj["font-family"]) || editorDefaults.fontFamily;
// 						const fontSize = cssSizeToHalfPoints(styleObj["font-size"]) || editorDefaults.fontSizeHalfPoints;
// 						runs.push({
// 							kind: "text",
// 							text,
// 							bold: node.hasFormat("bold"),
// 							italics: node.hasFormat("italic"),
// 							underline: node.hasFormat("underline"),
// 							strike: node.hasFormat("strikethrough"),
// 							code: node.hasFormat("code"),
// 							color,
// 							bgColor,
// 							fontFamily,
// 							fontSize,
// 							isLink: linkMeta?.isLink || false,
// 							url: linkMeta?.url,
// 						});
// 					}
// 				} else if (type === "linebreak") {
// 					runs.push({ kind: "break" });
// 				} else if (type === "link") {
// 					const url = node.getURL && node.getURL();
// 					node.getChildren().forEach((child) => {
// 						runs.push(...collectRunsFromNode(child, { isLink: true, url }));
// 					});
// 				} else if (type === "image") {
// 					runs.push({ kind: "image", src: node.getSrc && node.getSrc() });
// 				} else {
// 					if (node.getChildren) {
// 						node.getChildren().forEach((child) => {
// 							runs.push(...collectRunsFromNode(child, linkMeta));
// 						});
// 					}
// 				}
// 				return runs;
// 			};

// 			root.getChildren().forEach((node) => {
// 				const nodeType = node.getType();

// 				const nodeStyle = parseStyleToObject(node.getStyle && node.getStyle());
// 				const paraLine = cssLineHeightToDocxLine(nodeStyle["line-height"], editorDefaults.fontSizeHalfPoints);

// 				if (nodeType === "heading") {
// 					const tag = node.getTag && node.getTag();
// 					const runs = collectRunsFromNode(node);
// 					blocks.push({ kind: "heading", tag, runs, align: node.getFormatType && node.getFormatType(), line: paraLine });
// 				} else if (nodeType === "quote") {
// 					const runs = collectRunsFromNode(node);
// 					blocks.push({ kind: "quote", runs, align: node.getFormatType && node.getFormatType(), line: paraLine });
// 				} else if (nodeType === "list") {
// 					const listTag = node.getTag && node.getTag();
// 					const items = node.getChildren();
// 					items.forEach((listItem, idx) => {
// 						const runs = collectRunsFromNode(listItem);
// 						blocks.push({
// 							kind: "list-item",
// 							ordered: listTag === "ol",
// 							index: idx,
// 							runs,
// 							align: node.getFormatType && node.getFormatType(),
// 							line: paraLine,
// 						});
// 					});
// 				} else if (nodeType === "table") {
// 					const tableRows = [];
// 					const rowNodes = node.getChildren();
// 					rowNodes.forEach((rowNode) => {
// 						const rowCells = [];
// 						const cellNodes = rowNode.getChildren();
// 						cellNodes.forEach((cellNode) => {
// 							const paraNodes = cellNode.getChildren();
// 							const paragraphs = [];
// 							if (Array.isArray(paraNodes) && paraNodes.length > 0) {
// 								paraNodes.forEach((p) => {
// 									const pStyle = parseStyleToObject(p.getStyle && p.getStyle());
// 									const pLine = cssLineHeightToDocxLine(pStyle["line-height"], editorDefaults.fontSizeHalfPoints);
// 									const runs = collectRunsFromNode(p);
// 									paragraphs.push({ runs, align: p.getFormatType && p.getFormatType(), line: pLine });
// 								});
// 							} else {
// 								const runs = collectRunsFromNode(cellNode);
// 								paragraphs.push({ runs, align: cellNode.getFormatType && cellNode.getFormatType(), line: paraLine });
// 							}
// 							rowCells.push({ paragraphs });
// 						});
// 						tableRows.push(rowCells);
// 					});
// 					const dims = measuredTables[measuredTableIndex++] || null;
// 					blocks.push({ kind: "table", rows: tableRows, dims });
// 				} else if (nodeType === "paragraph") {
// 					const runs = collectRunsFromNode(node);
// 					blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine });
// 				} else if (nodeType === "image") {
// 					blocks.push({ kind: "paragraph", runs: [{ kind: "image", src: node.getSrc && node.getSrc() }], align: node.getFormatType && node.getFormatType(), line: paraLine });
// 				} else {
// 					const runs = collectRunsFromNode(node);
// 					if (runs.length > 0) {
// 						blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine });
// 					}
// 				}
// 			});
// 		});

// 		const dataUrlToUint8Array = async (dataUrl) => {
// 			const res = await fetch(dataUrl);
// 			const blob = await res.blob();
// 			const ab = await blob.arrayBuffer();
// 			return new Uint8Array(ab);
// 		};

// 		const loadImageElement = (src) => {
// 			return new Promise((resolve, reject) => {
// 				const img = new Image();
// 				img.onload = () => resolve(img);
// 				img.onerror = (e) => reject(e);
// 				img.src = src;
// 			});
// 		};

// 		const convertImageToPngBytes = async (img) => {
// 			try {
// 				const canvas = document.createElement("canvas");
// 				canvas.width = img.naturalWidth || img.width || 1;
// 				canvas.height = img.naturalHeight || img.height || 1;
// 				const ctx = canvas.getContext("2d");
// 				ctx.drawImage(img, 0, 0);
// 				const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
// 				if (!blob) return null;
// 				const ab = await blob.arrayBuffer();
// 				return new Uint8Array(ab);
// 			} catch (e) {
// 				console.warn("PNG conversion failed", e);
// 				return null;
// 			}
// 		};

// 		const sniffImageType = (bytes) => {
// 			if (!bytes || bytes.length < 12) return null;
// 			if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47 && bytes[4] === 0x0d && bytes[5] === 0x0a && bytes[6] === 0x1a && bytes[7] === 0x0a) {
// 				return "png";
// 			}
// 			if (bytes[0] === 0xff && bytes[1] === 0xd8) return "jpeg";
// 			if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38 && (bytes[4] === 0x39 || bytes[4] === 0x37) && bytes[5] === 0x61) {
// 				return "gif";
// 			}
// 			return null;
// 		};

// 		const tryBitmapToPng = async (blob) => {
// 			try {
// 				if (typeof createImageBitmap === "function") {
// 					const bitmap = await createImageBitmap(blob);
// 					const canvas = document.createElement("canvas");
// 					canvas.width = bitmap.width || 1;
// 					canvas.height = bitmap.height || 1;
// 					const ctx = canvas.getContext("2d");
// 					ctx.drawImage(bitmap, 0, 0);
// 					const out = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
// 					if (!out) return null;
// 					const ab = await out.arrayBuffer();
// 					return new Uint8Array(ab);
// 				}
// 			} catch (e) {
// 				console.warn("Bitmap conversion failed", e);
// 			}
// 			return null;
// 		};

// 		const resolveImage = async (src) => {
// 			if (!src) return null;
// 			let data;
// 			let width;
// 			let height;
// 			let type;

// 			if (src.startsWith("data:")) {
// 				try {
// 					const img = await loadImageElement(src);
// 					width = img.naturalWidth || 300;
// 					height = img.naturalHeight || 300;
// 					const png = await convertImageToPngBytes(img);
// 					if (png) {
// 						data = png;
// 						type = "png";
// 					} else {
// 						data = await dataUrlToUint8Array(src);
// 						type = sniffImageType(data) || "png";
// 					}
// 				} catch (e) {
// 					console.warn("Failed to load data URL image for DOCX:", e);
// 					data = await dataUrlToUint8Array(src);
// 					type = sniffImageType(data) || "png";
// 					width = 300;
// 					height = 300;
// 				}
// 			} else {
// 				const res = await fetch(src, { mode: "cors" }).catch((e) => {
// 					console.warn("Image fetch failed due to CORS or network:", src, e);
// 					return null;
// 				});
// 				if (!res || !res.ok) return null;
// 				const blob = await res.blob();
// 				const objectUrl = URL.createObjectURL(blob);
// 				try {
// 					const img = await loadImageElement(objectUrl);
// 					width = img.naturalWidth || 300;
// 					height = img.naturalHeight || 300;
// 					const png = await convertImageToPngBytes(img);
// 					if (png) {
// 						data = png;
// 						type = "png";
// 					} else {
// 						const ab = await blob.arrayBuffer();
// 						data = new Uint8Array(ab);
// 						type = sniffImageType(data);
// 						if (!type) {
// 							const conv = await tryBitmapToPng(blob);
// 							if (conv) {
// 								data = conv;
// 								type = "png";
// 							}
// 						}
// 					}
// 				} catch (e) {
// 					console.warn("Failed to load remote image into canvas, falling back to raw bytes", e);
// 					const ab = await blob.arrayBuffer();
// 					data = new Uint8Array(ab);
// 					type = sniffImageType(data);
// 					if (!type) {
// 						const conv = await tryBitmapToPng(blob);
// 						if (conv) {
// 							data = conv;
// 							type = "png";
// 						}
// 					}
// 					width = 300;
// 					height = 300;
// 				} finally {
// 					URL.revokeObjectURL(objectUrl);
// 				}
// 			}

// 			if (!data) return null;
// 			return { data, width, height, type: type || "png" };
// 		};

// 		const mapAlign = (align) => {
// 			switch (align) {
// 				case "center":
// 					return AlignmentType.CENTER;
// 				case "right":
// 					return AlignmentType.RIGHT;
// 				case "justify":
// 					return AlignmentType.JUSTIFIED;
// 				default:
// 					return AlignmentType.LEFT;
// 			}
// 		};

// 		const sectionChildren = [];

// 		const buildParagraphFromRuns = async (runs, align, line) => {
// 			const paraChildren = [];

// 			const pushTextSegments = (run) => {
// 				const baseOpts = {
// 					bold: !!run.bold,
// 					italics: !!run.italics,
// 					underline: run.underline || run.isLink ? {} : undefined,
// 					strike: !!run.strike,
// 					color: run.isLink ? "0000FF" : run.color,
// 					font: run.code ? "Courier New" : run.fontFamily,
// 					size: run.fontSize,
// 					shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
// 				};
// 				const text = run.text || "";
// 				const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
// 				const lines = text.split("\n");
// 				lines.forEach((lineText, li) => {
// 					const parts = lineText.split("\t");
// 					parts.forEach((part, pi) => {
// 						const t = normalizeSpaces(part);
// 						const tr = new TextRun({ text: t, ...baseOpts });
// 						if (run.isLink && run.url) {
// 							paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
// 						} else {
// 							paraChildren.push(tr);
// 						}
// 						if (pi < parts.length - 1) {
// 							paraChildren.push(new TextRun({ text: "\t" }));
// 						}
// 					});
// 					if (li < lines.length - 1) {
// 						paraChildren.push(new TextRun({ break: 1 }));
// 					}
// 				});
// 			};

// 			if (Array.isArray(runs)) {
// 				for (const run of runs) {
// 					if (run.kind === "image") {
// 						const img = await resolveImage(run.src);
// 						if (img) {
// 							paraChildren.push(
// 								new ImageRun({ data: img.data, transformation: { width: Math.min(500, img.width || 500), height: Math.min(500, img.height || 500) }, type: img.type })
// 							);
// 						}
// 					} else if (run.kind === "break") {
// 						paraChildren.push(new TextRun({ break: 1 }));
// 					} else {
// 						pushTextSegments(run);
// 					}
// 				}
// 			}

// 			return new Paragraph({ alignment: mapAlign(align), spacing: { before: 0, after: 0, line }, children: paraChildren });
// 		};

// 		for (const block of blocks) {
// 			if (block.kind === "list-item") {
// 				const childrenRuns = [];
// 				if (block.ordered) {
// 					childrenRuns.push(new TextRun({ text: `${(block.index || 0) + 1}. ` }));
// 				} else {
// 					childrenRuns.push(new TextRun({ text: "• " }));
// 				}
// 				for (const run of block.runs) {
// 					if (run.kind === "image") {
// 						const img = await resolveImage(run.src);
// 						if (img) {
// 							childrenRuns.push(
// 								new ImageRun({ data: img.data, transformation: { width: Math.min(500, img.width || 500), height: Math.min(500, img.height || 500) }, type: img.type })
// 							);
// 						}
// 					} else if (run.kind === "break") {
// 						childrenRuns.push(new TextRun({ break: 1 }));
// 					} else {
// 						const baseOpts = {
// 							bold: !!run.bold,
// 							italics: !!run.italics,
// 							underline: run.underline ? {} : undefined,
// 							strike: !!run.strike,
// 							color: run.isLink ? "0000FF" : run.color,
// 							font: run.code ? "Courier New" : run.fontFamily,
// 							size: run.fontSize,
// 							shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
// 						};
// 						const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
// 						const lines = (run.text || "").split("\n");
// 						lines.forEach((lineText, li) => {
// 							const parts = lineText.split("\t");
// 							parts.forEach((part, pi) => {
// 								const t = normalizeSpaces(part);
// 								const tr = new TextRun({ text: t, ...baseOpts });
// 								if (run.isLink && run.url) {
// 									childrenRuns.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
// 								} else {
// 									childrenRuns.push(tr);
// 								}
// 								if (pi < parts.length - 1) {
// 									childrenRuns.push(new TextRun({ text: "\t" }));
// 								}
// 							});
// 							if (li < lines.length - 1) {
// 								childrenRuns.push(new TextRun({ break: 1 }));
// 							}
// 						});
// 					}
// 				}
// 				sectionChildren.push(new Paragraph({ alignment: mapAlign(block.align), spacing: { before: 0, after: 0, line: block.line }, children: childrenRuns }));
// 				continue;
// 			}

// 			if (block.kind === "table") {
// 				const rows = [];
// 				const pageContentWidthTwips = 9360; // ~6.5 inches

// 				let columnWidths = [];
// 				let tableWidthTwips = pageContentWidthTwips;
// 				if (block.dims && Array.isArray(block.dims.colsTwips)) {
// 					const sum = block.dims.colsTwips.reduce((a, b) => a + b, 0) || 0;
// 					if (sum > 0) {
// 						const scale = sum > pageContentWidthTwips ? pageContentWidthTwips / sum : 1;
// 						columnWidths = block.dims.colsTwips.map((w) => Math.max(0, Math.floor(w * scale)));
// 						tableWidthTwips = Math.min(pageContentWidthTwips, Math.max(0, Math.floor(sum * scale)));
// 					}
// 				}

// 				if (!columnWidths.length) {
// 					const colsCount = (block.rows && block.rows[0] ? block.rows[0].length : 0) || 0;
// 					if (colsCount === 3) {
// 						columnWidths = [2200, 2200, pageContentWidthTwips - 2200 - 2200];
// 					} else if (colsCount > 0) {
// 						const each = Math.floor(pageContentWidthTwips / colsCount);
// 						columnWidths = new Array(colsCount).fill(each);
// 					}
// 				}

// 				for (const rowCells of block.rows) {
// 					const cells = [];
// 					for (let ci = 0; ci < rowCells.length; ci++) {
// 						const cell = rowCells[ci];
// 						const cellParagraphs = [];
// 						for (const p of cell.paragraphs) {
// 							cellParagraphs.push(await buildParagraphFromRuns(p.runs, p.align, p.line));
// 						}
// 						cells.push(
// 							new TableCell({
// 								children: cellParagraphs,
// 								width: columnWidths.length ? { size: columnWidths[ci] || columnWidths[0], type: WidthType.DXA } : undefined,
// 								margins: { top: 120, bottom: 120, left: 120, right: 120 },
// 							})
// 						);
// 					}
// 					rows.push(new TableRow({ children: cells }));
// 				}
// 				sectionChildren.push(
// 					new Table({
// 						width: { size: tableWidthTwips, type: WidthType.DXA },
// 						columnWidths: columnWidths.length ? columnWidths : undefined,
// 						alignment: AlignmentType.CENTER,
// 						layout: TableLayoutType.FIXED,
// 						rows,
// 						borders: {
// 							top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
// 							bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
// 							left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
// 							right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
// 							insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
// 							insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
// 						},
// 					})
// 				);
// 				continue;
// 			}

// 			const paraChildren = [];
// 			if (Array.isArray(block.runs)) {
// 				for (const run of block.runs) {
// 					if (run.kind === "image") {
// 						const img = await resolveImage(run.src);
// 						if (img) {
// 							paraChildren.push(
// 								new ImageRun({ data: img.data, transformation: { width: Math.min(500, img.width || 500), height: Math.min(500, img.height || 500) }, type: img.type })
// 							);
// 						}
// 					} else if (run.kind === "break") {
// 						paraChildren.push(new TextRun({ break: 1 }));
// 					} else {
// 						const baseOpts = {
// 							bold: !!run.bold,
// 							italics: !!run.italics,
// 							underline: run.underline || run.isLink ? {} : undefined,
// 							strike: !!run.strike,
// 							color: run.isLink ? "0000FF" : run.color,
// 							font: run.code ? "Courier New" : run.fontFamily,
// 							size: run.fontSize,
// 							shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
// 						};
// 						const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
// 						const lines = (run.text || "").split("\n");
// 						lines.forEach((lineText, li) => {
// 							const parts = lineText.split("\t");
// 							parts.forEach((part, pi) => {
// 								const t = normalizeSpaces(part);
// 								const tr = new TextRun({ text: t, ...baseOpts });
// 								if (run.isLink && run.url) {
// 									paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
// 								} else {
// 									paraChildren.push(tr);
// 								}
// 								if (pi < parts.length - 1) {
// 									paraChildren.push(new TextRun({ text: "\t" }));
// 								}
// 							});
// 							if (li < lines.length - 1) {
// 								paraChildren.push(new TextRun({ break: 1 }));
// 							}
// 						});
// 					}
// 				}
// 			}

// 			if (block.kind === "heading") {
// 				const headingLevel = block.tag === "h1" ? HeadingLevel.HEADING_1 : block.tag === "h2" ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3;
// 				sectionChildren.push(new Paragraph({ heading: headingLevel, alignment: mapAlign(block.align), spacing: { before: 0, after: 0, line: block.line }, children: paraChildren }));
// 			} else if (block.kind === "quote") {
// 				sectionChildren.push(new Paragraph({ alignment: mapAlign(block.align), spacing: { before: 0, after: 0, line: block.line }, children: [new TextRun({ text: "“" }), ...paraChildren, new TextRun({ text: "”" })] }));
// 			} else {
// 				sectionChildren.push(new Paragraph({ alignment: mapAlign(block.align), spacing: { before: 0, after: 0, line: block.line }, children: paraChildren }));
// 			}
// 		}

// 		const doc = new Document({
// 			sections: [
// 				{
// 					properties: {},
// 					children: sectionChildren,
// 				},
// 			],
// 		});

// 		const blob = await Packer.toBlob(doc);
// 		saveAs(blob, "document.docx");
// 	};

// 	// Enhanced onChange to log editor state content
// 	function onChange(editorState) {
// 		editorState.read(() => {
// 			const root = $getRoot();
// 			console.log("Editor State Content:");
// 			root.getChildren().forEach((node, index) => {
// 				console.log(`Node ${index + 1}: Type=${node.getType()}`);
// 				if (node.getType() === "paragraph") {
// 					console.log("  Paragraph content:");
// 					node.getChildren().forEach((child, childIndex) => {
// 						console.log(`    Child ${childIndex + 1}: Type=${child.getType()}`);
// 						if (child.getType() === "text") {
// 							console.log(`      Text: ${child.getTextContent()}`);
// 							console.log(`      Formats: Bold=${child.hasFormat("bold")}, Italic=${child.hasFormat("italic")}, Underline=${child.hasFormat("underline")}`);
// 						} else if (child.getType() === "link") {
// 							console.log(`      Link Text: ${child.getTextContent()}, URL: ${child.getURL()}`);
// 						}
// 					});
// 				} else if (node.getType() === "list") {
// 					console.log("  List content:");
// 					node.getChildren().forEach((listItem, itemIndex) => {
// 						console.log(`    Item ${itemIndex + 1}: ${listItem.getTextContent()}`);
// 					});
// 				}
// 			});
// 		});
// 	}

// 	function ColorToolbar() {
// 	const [editor] = useLexicalComposerContext();
// 	const [fontColor, setFontColor] = useState("#000000");
// 	const [bgColor, setBgColor] = useState("#ffffff");
 
// 	// Apply color styles to current selection
// 	const applyStyle = (style) => {
// 		editor.update(() => {
// 			$patchStyleText(style);
// 		});
// 	};
 
// 	// Listen to selection changes and update toolbar
// 	const updateToolbar = () => {
// 		editor.getEditorState().read(() => {
// 			const selection = $getSelection();
// 			if ($isRangeSelection(selection)) {
// 				const styles = $getSelection(); // Get inline styles
// 				console.log(styles,'styles')
// 				setFontColor(styles.color || "#000000");
// 				setBgColor(styles["background-color"] || "#ffffff");
// 			}
// 		});
// 	};
 
// 	return (
// 		<>
// 			{/* Sync toolbar with editor selection */}
// 			<OnChangePlugin
// 				onChange={() => {
// 					updateToolbar();
// 				}}
// 			/>
 
// 			<div className="flex space-x-4 p-2 border-b bg-gray-50">
// 				{/* Font Color Picker */}
// 				<label className="flex items-center space-x-1">
// 					<span>Font:</span>
// 					<input
// 						type="color"
// 						value={fontColor}
// 						onChange={(e) => {
// 		setFontColor(e.target.value);
// 		applyStyle({ color: e.target.value });
// 						}}
// 					/>
// 				</label>
 
// 				{/* Background Color Picker */}
// 				<label className="flex items-center space-x-1">
// 					<span>Bg:</span>
// 					<input
// 						type="color"
// 						value={bgColor}
// 						onChange={(e) => {
// 		setBgColor(e.target.value);
// 		applyStyle({ "background-color": e.target.value });
// 						}}
// 					/>
// 				</label>
// 			</div>
// 		</>
// 	);
// }

// 	function downloadHtml(editor) {
// 		let html = "";
// 		editor.getEditorState().read(() => {
// 			html = $generateHtmlFromNodes(editor);
// 		});
// 		const blob = new Blob(
// 			[ "<!doctype html><meta charset=utf-8>" + html ],
// 			{ type: "text/html;charset=utf-8" }
// 		);
// 		saveAs(blob, "document.html");
// 	}

// 	async function downloadDocxFromHtml(editor) {
// 		const { $generateHtmlFromNodes } = await import("@lexical/html");
// 		const { default: HTMLtoDOCX } = await import("html-to-docx"); // HTML → DOCX

// 		let html = "";
// 		editor.getEditorState().read(() => {
// 			html = $generateHtmlFromNodes(editor);
// 		});

// 		const wrapped = `<div style="white-space: pre-wrap">${html}</div>`;
// 		const buf = await HTMLtoDOCX(wrapped, null, {
// 			css: "table{border-collapse:collapse}td,th{border:1px solid #000;padding:4px} img{max-width:600px}"
// 		});

// 		saveAs(new Blob([buf], {
// 			type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
// 		}), "document.docx");
// 	}

// 	return (
// 		<LexicalComposer initialConfig={lexicalEditorConfig}>
// 			<LexicalEditorTopBar onDownloadDocx={handleDownloadDocx} />
// 			<Divider />
// 			{/* <ColorToolbar/> */}
// 			{/* <div className="toolbar flex items-center space-x-4 p-2 border-b">
// 				<ColorPlugin />
// 			</div> */}
// 			<Box sx={{ position: "relative", background: "white" }}>
// 				<RichTextPlugin
// 					contentEditable={<MuiContentEditable />}
// 					placeholder={<Box sx={placeHolderSx}>Enter some text...</Box>}
// 					ErrorBoundary={LexicalErrorBoundary}
// 				/>
// 				{/* <OnChangePlugin onChange={onChange} /> */}
// 				<HistoryPlugin />
// 					{/* <OnChangePlugin
// 				onChange={() => {
// 					updateToolbar();
// 				}}
// 			/> */}
// 				{/* <TreeViewPlugin /> */}
// 				<ListPlugin />
// 				<LinkPlugin />
// 				<ImagesPlugin captionsEnabled={false} />
// 				<FloatingTextFormatToolbarPlugin />
// 				<TablePlugin/>
// 			</Box>
// 		</LexicalComposer>
// 	);
// }

// function MyCustomAutoFocusPlugin() {
// 	const [editor] = useLexicalComposerContext();

// 	useEffect(() => {
// 		editor.focus();
// 	}, [editor]);

// 	return null;
// }

// export default LexicalEditorWrapper;

import { $getRoot, $getSelection, $isRangeSelection } from "lexical";
import { useEffect, useState } from "react";
import { LexicalComposer } from "@lexical/react/LexicalComposer";
import { HistoryPlugin } from "@lexical/react/LexicalHistoryPlugin";
import { OnChangePlugin } from "@lexical/react/LexicalOnChangePlugin";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
import { MuiContentEditable, placeHolderSx } from "./styles";
import { Box, Divider } from "@mui/material";
import { lexicalEditorConfig } from "../../config/lexicalEditorConfig";
import LexicalEditorTopBar from "../LexicalEditorTopBar";
import TreeViewPlugin from "../CustomPlugins/TreeViewPlugin";
import { ListPlugin } from "@lexical/react/LexicalListPlugin";
import { LinkPlugin } from "@lexical/react/LexicalLinkPlugin";
import ImagesPlugin from "../CustomPlugins/ImagePlugin";
import FloatingTextFormatToolbarPlugin from "../CustomPlugins/FloatingTextFormatPlugin";
import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
import { Document, Packer, Paragraph, TextRun, ImageRun, AlignmentType, HeadingLevel, ExternalHyperlink, ShadingType, Table, TableRow, TableCell, WidthType, BorderStyle, TableLayoutType } from "docx";
import { saveAs } from "file-saver";
import ColorPlugin from "../CustomPlugins/ColorPlugin";
import {
	$patchStyleText,
	$getSelectionStyleValueForProperty,
} from "@lexical/selection";
import { TablePlugin } from "@lexical/react/LexicalTablePlugin";
import { $generateHtmlFromNodes } from "@lexical/html";

function LexicalEditorWrapper(props) {
	// Function to handle DOCX download
	// const handleDownloadDocx = async (editor) => {
	// 	const editorState = editor.getEditorState();
	// 	const blocks = [];

	// 	// Capture editor-level default font family and size from DOM
	// 	const readEditorDefaults = () => {
	// 		const rootEl = document.querySelector('.ContentEditable__root');
	// 		const cs = rootEl ? window.getComputedStyle(rootEl) : null;
	// 		const fontFamily = cs?.fontFamily ? cs.fontFamily.split(',')[0].replace(/["']/g, '').trim() : undefined;
	// 		const fontSizePx = cs?.fontSize ? parseFloat(cs.fontSize) : undefined;
	// 		const fontSizeHalfPoints = Number.isFinite(fontSizePx) ? Math.round((fontSizePx * 0.75) * 2) : undefined; // px->pt->halfPoints
	// 		return { fontFamily, fontSizeHalfPoints };
	// 	};
	// 	const editorDefaults = readEditorDefaults();

	// 	// Measure table column widths directly from the DOM so DOCX matches the editor UI
	// 	const measureTablesFromDOM = () => {
	// 		const results = [];
	// 		const rootEl = document.querySelector('.ContentEditable__root');
	// 		if (!rootEl) return results;
	// 		const tableEls = rootEl.querySelectorAll('table');
	// 		tableEls.forEach((table) => {
	// 			try {
	// 				const firstRow = table.rows && table.rows[0];
	// 				if (!firstRow) {
	// 					results.push(null);
	// 					return;
	// 				}
	// 				const colWidthsPx = [];
	// 				for (let ci = 0; ci < firstRow.cells.length; ci++) {
	// 					const rect = firstRow.cells[ci].getBoundingClientRect();
	// 					colWidthsPx.push(Math.max(0, Math.round(rect.width)));
	// 				}
	// 				const totalPx = colWidthsPx.reduce((a, b) => a + b, 0);
	// 				const pxToTwips = (px) => Math.max(0, Math.round(px * 15)); // 1px≈1/96in; 1in=1440 twips => 1440/96=15
	// 				const colsTwips = colWidthsPx.map(pxToTwips);
	// 				const totalTwips = pxToTwips(totalPx);
	// 				results.push({ colsTwips, totalTwips });
	// 			} catch (e) {
	// 				results.push(null);
	// 			}
	// 		});
	// 		return results;
	// 	};

	// 	const measuredTables = measureTablesFromDOM();
	// 	let measuredTableIndex = 0;

	// 	const parseStyleToObject = (styleString) => {
	// 		const style = {};
	// 		if (!styleString) return style;
	// 		styleString.split(";").forEach((decl) => {
	// 			const [prop, val] = decl.split(":");
	// 			if (prop && val) {
	// 				style[prop.trim()] = val.trim();
	// 			}
	// 		});
	// 		return style;
	// 	};

	// 	const normalizeFontFamily = (family) => {
	// 		if (!family) return undefined;
	// 		const first = family.split(",")[0] || "";
	// 		return first.replace(/["']/g, "").trim() || undefined;
	// 	};

	// 	const cssSizeToHalfPoints = (size) => {
	// 		if (!size) return undefined;
	// 		const s = String(size).trim().toLowerCase();
	// 		if (s.endsWith("pt")) {
	// 			const pt = parseFloat(s);
	// 			return Number.isFinite(pt) ? Math.round(pt * 2) : undefined;
	// 		}
	// 		if (s.endsWith("px")) {
	// 			const px = parseFloat(s);
	// 			if (!Number.isFinite(px)) return undefined;
	// 			const pt = px * 0.75; // 1pt = 1.333px => pt = px * 0.75
	// 			return Math.round(pt * 2);
	// 		}
	// 		return undefined;
	// 	};

	// 	const colorToHexNoHash = (c) => {
	// 		if (!c) return undefined;
	// 		const m = c.trim();
	// 		if (m.startsWith("#")) return m.slice(1).toUpperCase();
	// 		return m.toUpperCase();
	// 	};

	// 	const cssLineHeightToDocxLine = (lineHeight, fallbackHalfPoints) => {
	// 		if (!lineHeight) return undefined;
	// 		const s = String(lineHeight).trim().toLowerCase();
	// 		if (s.endsWith('%')) {
	// 			const pct = parseFloat(s);
	// 			if (Number.isFinite(pct)) return Math.round((pct / 100) * 240);
	// 		}
	// 		const num = parseFloat(s);
	// 		if (Number.isFinite(num) && !s.endsWith('px') && !s.endsWith('pt')) {
	// 			return Math.round(num * 240); // 1.0 -> 240
	// 		}
	// 		let linePt;
	// 		if (s.endsWith('pt')) {
	// 			linePt = parseFloat(s);
	// 		} else if (s.endsWith('px')) {
	// 			const px = parseFloat(s);
	// 			linePt = Number.isFinite(px) ? px * 0.75 : undefined;
	// 		}
	// 		if (Number.isFinite(linePt)) {
	// 			const fontPt = fallbackHalfPoints ? fallbackHalfPoints / 2 : 11; // default ~11pt
	// 			const mult = linePt / fontPt;
	// 			return Math.round(mult * 240);
	// 		}
	// 		return undefined;
	// 	};

	// 	editorState.read(() => {
	// 		const root = $getRoot();

	// 		const collectRunsFromNode = (node, linkMeta) => {
	// 			const runs = [];
	// 			const type = node.getType();
	// 			if (type === "text") {
	// 				const text = node.getTextContent();
	// 				if (text && text.length > 0) {
	// 					const styleObj = parseStyleToObject(node.getStyle && node.getStyle());
	// 					const color = colorToHexNoHash(styleObj["color"]);
	// 					const bgColor = colorToHexNoHash(styleObj["background-color"]);
	// 					const fontFamily = normalizeFontFamily(styleObj["font-family"]) || editorDefaults.fontFamily;
	// 					const fontSize = cssSizeToHalfPoints(styleObj["font-size"]) || editorDefaults.fontSizeHalfPoints;
	// 					runs.push({
	// 						kind: "text",
	// 						text,
	// 						bold: node.hasFormat("bold"),
	// 						italics: node.hasFormat("italic"),
	// 						underline: node.hasFormat("underline"),
	// 						strike: node.hasFormat("strikethrough"),
	// 						code: node.hasFormat("code"),
	// 						color,
	// 						bgColor,
	// 						fontFamily,
	// 						fontSize,
	// 						isLink: linkMeta?.isLink || false,
	// 						url: linkMeta?.url,
	// 					});
	// 				}
	// 			} else if (type === "linebreak") {
	// 				runs.push({ kind: "break" });
	// 			} else if (type === "link") {
	// 				const url = node.getURL && node.getURL();
	// 				node.getChildren().forEach((child) => {
	// 					runs.push(...collectRunsFromNode(child, { isLink: true, url }));
	// 				});
	// 			} else if (type === "image") {
	// 				runs.push({ kind: "image", src: node.getSrc && node.getSrc() });
	// 			} else {
	// 				if (node.getChildren) {
	// 					node.getChildren().forEach((child) => {
	// 						runs.push(...collectRunsFromNode(child, linkMeta));
	// 					});
	// 				}
	// 			}
	// 			return runs;
	// 		};

	// 		root.getChildren().forEach((node) => {
	// 			const nodeType = node.getType();

	// 			const nodeStyle = parseStyleToObject(node.getStyle && node.getStyle());
	// 			const paraLine = cssLineHeightToDocxLine(nodeStyle["line-height"], editorDefaults.fontSizeHalfPoints);

	// 			if (nodeType === "heading") {
	// 				const tag = node.getTag && node.getTag();
	// 				const runs = collectRunsFromNode(node);
	// 				blocks.push({ kind: "heading", tag, runs, align: node.getFormatType && node.getFormatType(), line: paraLine });
	// 			} else if (nodeType === "quote") {
	// 				const runs = collectRunsFromNode(node);
	// 				blocks.push({ kind: "quote", runs, align: node.getFormatType && node.getFormatType(), line: paraLine });
	// 			} else if (nodeType === "list") {
	// 				const listTag = node.getTag && node.getTag();
	// 				const items = node.getChildren();
	// 				items.forEach((listItem, idx) => {
	// 					const runs = collectRunsFromNode(listItem);
	// 					blocks.push({
	// 						kind: "list-item",
	// 						ordered: listTag === "ol",
	// 						index: idx,
	// 						runs,
	// 						align: node.getFormatType && node.getFormatType(),
	// 						line: paraLine,
	// 					});
	// 				});
	// 			} else if (nodeType === "table") {
	// 				const tableRows = [];
	// 				const rowNodes = node.getChildren();
	// 				rowNodes.forEach((rowNode) => {
	// 					const rowCells = [];
	// 					const cellNodes = rowNode.getChildren();
	// 					cellNodes.forEach((cellNode) => {
	// 						const paraNodes = cellNode.getChildren();
	// 						const paragraphs = [];
	// 						if (Array.isArray(paraNodes) && paraNodes.length > 0) {
	// 							paraNodes.forEach((p) => {
	// 								const pStyle = parseStyleToObject(p.getStyle && p.getStyle());
	// 								const pLine = cssLineHeightToDocxLine(pStyle["line-height"], editorDefaults.fontSizeHalfPoints);
	// 								const runs = collectRunsFromNode(p);
	// 								paragraphs.push({ runs, align: p.getFormatType && p.getFormatType(), line: pLine });
	// 							});
	// 						} else {
	// 							const runs = collectRunsFromNode(cellNode);
	// 							paragraphs.push({ runs, align: cellNode.getFormatType && cellNode.getFormatType(), line: paraLine });
	// 						}
	// 						rowCells.push({ paragraphs });
	// 					});
	// 					tableRows.push(rowCells);
	// 				});
	// 				const dims = measuredTables[measuredTableIndex++] || null;
	// 				blocks.push({ kind: "table", rows: tableRows, dims });
	// 			} else if (nodeType === "paragraph") {
	// 				const runs = collectRunsFromNode(node);
	// 				blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine });
	// 			} else if (nodeType === "image") {
	// 				blocks.push({ kind: "paragraph", runs: [{ kind: "image", src: node.getSrc && node.getSrc() }], align: node.getFormatType && node.getFormatType(), line: paraLine });
	// 			} else {
	// 				const runs = collectRunsFromNode(node);
	// 				if (runs.length > 0) {
	// 					blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine });
	// 				}
	// 			}
	// 		});
	// 	});

	// 	const dataUrlToUint8Array = async (dataUrl) => {
	// 		const res = await fetch(dataUrl);
	// 		const blob = await res.blob();
	// 		const ab = await blob.arrayBuffer();
	// 		return new Uint8Array(ab);
	// 	};

	// 	const loadImageElement = (src) => {
	// 		return new Promise((resolve, reject) => {
	// 			const img = new Image();
	// 			img.onload = () => resolve(img);
	// 			img.onerror = (e) => reject(e);
	// 			img.src = src;
	// 		});
	// 	};

	// 	const convertImageToPngBytes = async (img) => {
	// 		try {
	// 			const canvas = document.createElement("canvas");
	// 			canvas.width = img.naturalWidth || img.width || 1;
	// 			canvas.height = img.naturalHeight || img.height || 1;
	// 			const ctx = canvas.getContext("2d");
	// 			ctx.drawImage(img, 0, 0);
	// 			const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
	// 			if (!blob) return null;
	// 			const ab = await blob.arrayBuffer();
	// 			return new Uint8Array(ab);
	// 		} catch (e) {
	// 			console.warn("PNG conversion failed", e);
	// 			return null;
	// 		}
	// 	};

	// 	const sniffImageType = (bytes) => {
	// 		if (!bytes || bytes.length < 12) return null;
	// 		if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47 && bytes[4] === 0x0d && bytes[5] === 0x0a && bytes[6] === 0x1a && bytes[7] === 0x0a) {
	// 			return "png";
	// 		}
	// 		if (bytes[0] === 0xff && bytes[1] === 0xd8) return "jpeg";
	// 		if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38 && (bytes[4] === 0x39 || bytes[4] === 0x37) && bytes[5] === 0x61) {
	// 			return "gif";
	// 		}
	// 		return null;
	// 	};

	// 	const tryBitmapToPng = async (blob) => {
	// 		try {
	// 			if (typeof createImageBitmap === "function") {
	// 				const bitmap = await createImageBitmap(blob);
	// 				const canvas = document.createElement("canvas");
	// 				canvas.width = bitmap.width || 1;
	// 				canvas.height = bitmap.height || 1;
	// 				const ctx = canvas.getContext("2d");
	// 				ctx.drawImage(bitmap, 0, 0);
	// 				const out = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
	// 				if (!out) return null;
	// 				const ab = await out.arrayBuffer();
	// 				return new Uint8Array(ab);
	// 			}
	// 		} catch (e) {
	// 			console.warn("Bitmap conversion failed", e);
	// 		}
	// 		return null;
	// 	};

	// 	const resolveImage = async (src) => {
	// 		if (!src) return null;
	// 		let data;
	// 		let width;
	// 		let height;
	// 		let type;

	// 		if (src.startsWith("data:")) {
	// 			try {
	// 				const img = await loadImageElement(src);
	// 				width = img.naturalWidth || 300;
	// 				height = img.naturalHeight || 300;
	// 				const png = await convertImageToPngBytes(img);
	// 				if (png) {
	// 					data = png;
	// 					type = "png";
	// 				} else {
	// 					data = await dataUrlToUint8Array(src);
	// 					type = sniffImageType(data) || "png";
	// 				}
	// 			} catch (e) {
	// 				console.warn("Failed to load data URL image for DOCX:", e);
	// 				data = await dataUrlToUint8Array(src);
	// 				type = sniffImageType(data) || "png";
	// 				width = 300;
	// 				height = 300;
	// 			}
	// 		} else {
	// 			const res = await fetch(src, { mode: "cors" }).catch((e) => {
	// 				console.warn("Image fetch failed due to CORS or network:", src, e);
	// 				return null;
	// 			});
	// 			if (!res || !res.ok) return null;
	// 			const blob = await res.blob();
	// 			const objectUrl = URL.createObjectURL(blob);
	// 			try {
	// 				const img = await loadImageElement(objectUrl);
	// 				width = img.naturalWidth || 300;
	// 				height = img.naturalHeight || 300;
	// 				const png = await convertImageToPngBytes(img);
	// 				if (png) {
	// 					data = png;
	// 					type = "png";
	// 				} else {
	// 					const ab = await blob.arrayBuffer();
	// 					data = new Uint8Array(ab);
	// 					type = sniffImageType(data);
	// 					if (!type) {
	// 						const conv = await tryBitmapToPng(blob);
	// 						if (conv) {
	// 							data = conv;
	// 							type = "png";
	// 						}
	// 					}
	// 				}
	// 			} catch (e) {
	// 				console.warn("Failed to load remote image into canvas, falling back to raw bytes", e);
	// 				const ab = await blob.arrayBuffer();
	// 				data = new Uint8Array(ab);
	// 				type = sniffImageType(data);
	// 				if (!type) {
	// 					const conv = await tryBitmapToPng(blob);
	// 					if (conv) {
	// 						data = conv;
	// 						type = "png";
	// 					}
	// 				}
	// 				width = 300;
	// 				height = 300;
	// 			} finally {
	// 				URL.revokeObjectURL(objectUrl);
	// 			}
	// 		}

	// 		if (!data) return null;
	// 		return { data, width, height, type: type || "png" };
	// 	};

	// 	const mapAlign = (align) => {
	// 		switch (align) {
	// 			case "center":
	// 				return AlignmentType.CENTER;
	// 			case "right":
	// 				return AlignmentType.RIGHT;
	// 			case "justify":
	// 				return AlignmentType.JUSTIFIED;
	// 			default:
	// 				return AlignmentType.LEFT;
	// 		}
	// 	};

	// 	const sectionChildren = [];

	// 	const buildParagraphFromRuns = async (runs, align, line) => {
	// 		const paraChildren = [];

	// 		const pushTextSegments = (run) => {
	// 			const baseOpts = {
	// 				bold: !!run.bold,
	// 				italics: !!run.italics,
	// 				underline: run.underline || run.isLink ? {} : undefined,
	// 				strike: !!run.strike,
	// 				color: run.isLink ? "0000FF" : run.color,
	// 				font: run.code ? "Courier New" : run.fontFamily,
	// 				size: run.fontSize,
	// 				shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
	// 			};
	// 			const text = run.text || "";
	// 			const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
	// 			const lines = text.split("\n");
	// 			lines.forEach((lineText, li) => {
	// 				const parts = lineText.split("\t");
	// 				parts.forEach((part, pi) => {
	// 					const t = normalizeSpaces(part);
	// 					const tr = new TextRun({ text: t, ...baseOpts });
	// 					if (run.isLink && run.url) {
	// 						paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
	// 					} else {
	// 						paraChildren.push(tr);
	// 					}
	// 					if (pi < parts.length - 1) {
	// 						paraChildren.push(new TextRun({ text: "\t" }));
	// 					}
	// 				});
	// 				if (li < lines.length - 1) {
	// 					paraChildren.push(new TextRun({ break: 1 }));
	// 				}
	// 			});
	// 		};

	// 		if (Array.isArray(runs)) {
	// 			for (const run of runs) {
	// 				if (run.kind === "image") {
	// 					const img = await resolveImage(run.src);
	// 					if (img) {
	// 						paraChildren.push(
	// 							new ImageRun({ 
	// 								data: img.data, 
	// 								transformation: { width: Math.min(500, img.width || 500), height: Math.min(500, img.height || 500) }, 
	// 								type: img.type 
	// 							})
	// 						);
	// 					}
	// 				} else if (run.kind === "break") {
	// 					paraChildren.push(new TextRun({ break: 1 }));
	// 				} else {
	// 					pushTextSegments(run);
	// 				}
	// 			}
	// 		}

	// 		return new Paragraph({ 
	// 			alignment: mapAlign(align), 
	// 			spacing: { before: 0, after: 240, line }, // Added spacing.after
	// 			children: paraChildren 
	// 		});
	// 	};

	// 	for (const block of blocks) {
	// 		if (block.kind === "list-item") {
	// 			const childrenRuns = [];
	// 			if (block.ordered) {
	// 				childrenRuns.push(new TextRun({ text: `${(block.index || 0) + 1}. ` }));
	// 			} else {
	// 				childrenRuns.push(new TextRun({ text: "• " }));
	// 			}
	// 			for (const run of block.runs) {
	// 				if (run.kind === "image") {
	// 					const img = await resolveImage(run.src);
	// 					if (img) {
	// 						childrenRuns.push(
	// 							new ImageRun({ 
	// 								data: img.data, 
	// 								transformation: { width: Math.min(500, img.width || 500), height: Math.min(500, img.height || 500) }, 
	// 								type: img.type 
	// 							})
	// 						);
	// 					}
	// 				} else if (run.kind === "break") {
	// 					childrenRuns.push(new TextRun({ break: 1 }));
	// 				} else {
	// 					const baseOpts = {
	// 						bold: !!run.bold,
	// 						italics: !!run.italics,
	// 						underline: run.underline ? {} : undefined,
	// 						strike: !!run.strike,
	// 						color: run.isLink ? "0000FF" : run.color,
	// 						font: run.code ? "Courier New" : run.fontFamily,
	// 						size: run.fontSize,
	// 						shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
	// 					};
	// 					const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
	// 					const lines = (run.text || "").split("\n");
	// 					lines.forEach((lineText, li) => {
	// 						const parts = lineText.split("\t");
	// 						parts.forEach((part, pi) => {
	// 							const t = normalizeSpaces(part);
	// 							const tr = new TextRun({ text: t, ...baseOpts });
	// 							if (run.isLink && run.url) {
	// 								childrenRuns.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
	// 							} else {
	// 								childrenRuns.push(tr);
	// 							}
	// 							if (pi < parts.length - 1) {
	// 								childrenRuns.push(new TextRun({ text: "\t" }));
	// 							}
	// 						});
	// 						if (li < lines.length - 1) {
	// 							childrenRuns.push(new TextRun({ break: 1 }));
	// 						}
	// 					});
	// 				}
	// 			}
	// 			sectionChildren.push(
	// 				new Paragraph({ 
	// 					alignment: mapAlign(block.align), 
	// 					spacing: { before: 0, after: 120, line: block.line }, // Smaller spacing for lists
	// 					children: childrenRuns 
	// 				})
	// 			);
	// 			continue;
	// 		}

	// 		if (block.kind === "table") {
	// 			const rows = [];
	// 			const pageContentWidthTwips = 9360; // ~6.5 inches

	// 			let columnWidths = [];
	// 			let tableWidthTwips = pageContentWidthTwips;
	// 			if (block.dims && Array.isArray(block.dims.colsTwips)) {
	// 				const sum = block.dims.colsTwips.reduce((a, b) => a + b, 0) || 0;
	// 				if (sum > 0) {
	// 					const scale = sum > pageContentWidthTwips ? pageContentWidthTwips / sum : 1;
	// 					columnWidths = block.dims.colsTwips.map((w) => Math.max(0, Math.floor(w * scale)));
	// 					tableWidthTwips = Math.min(pageContentWidthTwips, Math.max(0, Math.floor(sum * scale)));
	// 				}
	// 			}

	// 			if (!columnWidths.length) {
	// 				const colsCount = (block.rows && block.rows[0] ? block.rows[0].length : 0) || 0;
	// 				if (colsCount === 3) {
	// 					columnWidths = [2200, 2200, pageContentWidthTwips - 2200 - 2200];
	// 				} else if (colsCount > 0) {
	// 					const each = Math.floor(pageContentWidthTwips / colsCount);
	// 					columnWidths = new Array(colsCount).fill(each);
	// 				}
	// 			}

	// 			for (const rowCells of block.rows) {
	// 				const cells = [];
	// 				for (let ci = 0; ci < rowCells.length; ci++) {
	// 					const cell = rowCells[ci];
	// 					const cellParagraphs = [];
	// 					for (const p of cell.paragraphs) {
	// 						cellParagraphs.push(
	// 							await buildParagraphFromRuns(p.runs, p.align, p.line, { spacing: { after: 120 } }) // Spacing in table cells
	// 						);
	// 					}
	// 					cells.push(
	// 						new TableCell({
	// 							children: cellParagraphs,
	// 							width: columnWidths.length ? { size: columnWidths[ci] || columnWidths[0], type: WidthType.DXA } : undefined,
	// 							margins: { top: 120, bottom: 120, left: 120, right: 120 },
	// 						})
	// 					);
	// 				}
	// 				rows.push(new TableRow({ children: cells }));
	// 			}
	// 			sectionChildren.push(
	// 				new Table({
	// 					width: { size: tableWidthTwips, type: WidthType.DXA },
	// 					columnWidths: columnWidths.length ? columnWidths : undefined,
	// 					alignment: AlignmentType.CENTER,
	// 					layout: TableLayoutType.FIXED,
	// 					rows,
	// 					borders: {
	// 						top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 						bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 						left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 						right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 						insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 						insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 					},
	// 				})
	// 			);
	// 			continue;
	// 		}

	// 		const paraChildren = [];
	// 		if (Array.isArray(block.runs)) {
	// 			for (const run of block.runs) {
	// 				if (run.kind === "image") {
	// 					const img = await resolveImage(run.src);
	// 					if (img) {
	// 						paraChildren.push(
	// 							new ImageRun({ 
	// 								data: img.data, 
	// 								transformation: { width: Math.min(500, img.width || 500), height: Math.min(500, img.height || 500) }, 
	// 								type: img.type 
	// 							})
	// 						);
	// 					}
	// 				} else if (run.kind === "break") {
	// 					paraChildren.push(new TextRun({ break: 1 }));
	// 				} else {
	// 					const baseOpts = {
	// 						bold: !!run.bold,
	// 						italics: !!run.italics,
	// 						underline: run.underline || run.isLink ? {} : undefined,
	// 						strike: !!run.strike,
	// 						color: run.isLink ? "0000FF" : run.color,
	// 						font: run.code ? "Courier New" : run.fontFamily,
	// 						size: run.fontSize,
	// 						shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
	// 					};
	// 					const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
	// 					const lines = (run.text || "").split("\n");
	// 					lines.forEach((lineText, li) => {
	// 						const parts = lineText.split("\t");
	// 						parts.forEach((part, pi) => {
	// 							const t = normalizeSpaces(part);
	// 							const tr = new TextRun({ text: t, ...baseOpts });
	// 							if (run.isLink && run.url) {
	// 								paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
	// 							} else {
	// 								paraChildren.push(tr);
	// 							}
	// 							if (pi < parts.length - 1) {
	// 								paraChildren.push(new TextRun({ text: "\t" }));
	// 							}
	// 						});
	// 						if (li < lines.length - 1) {
	// 							paraChildren.push(new TextRun({ break: 1 }));
	// 						}
	// 					});
	// 				}
	// 			}
	// 		}

	// 		if (block.kind === "heading") {
	// 			const headingLevel = block.tag === "h1" ? HeadingLevel.HEADING_1 : block.tag === "h2" ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3;
	// 			sectionChildren.push(
	// 				new Paragraph({ 
	// 					heading: headingLevel, 
	// 					alignment: mapAlign(block.align), 
	// 					spacing: { before: 240, after: 240, line: block.line }, // Added spacing
	// 					children: paraChildren 
	// 				})
	// 			);
	// 		} else if (block.kind === "quote") {
	// 			sectionChildren.push(
	// 				new Paragraph({ 
	// 					alignment: mapAlign(block.align), 
	// 					spacing: { before: 0, after: 240, line: block.line }, // Added spacing
	// 					children: [new TextRun({ text: "“" }), ...paraChildren, new TextRun({ text: "”" })] 
	// 				})
	// 			);
	// 		} else {
	// 			sectionChildren.push(
	// 				new Paragraph({ 
	// 					alignment: mapAlign(block.align), 
	// 					spacing: { before: 0, after: 240, line: block.line }, // Added spacing
	// 					children: paraChildren 
	// 				})
	// 			);
	// 		}
	// 	}

	// 	const doc = new Document({
	// 		sections: [
	// 			{
	// 				properties: {},
	// 				children: sectionChildren,
	// 			},
	// 		],
	// 	});

	// 	const blob = await Packer.toBlob(doc);
	// 	saveAs(blob, "document.docx");
	// };
	// const handleDownloadDocx = async (editor) => {
	// 	const editorState = editor.getEditorState();
	// 	const blocks = [];
	  
	// 	// Capture editor-level default font family and size from DOM
	// 	const readEditorDefaults = () => {
	// 	  const rootEl = document.querySelector('.ContentEditable__root');
	// 	  const cs = rootEl ? window.getComputedStyle(rootEl) : null;
	// 	  const fontFamily = cs?.fontFamily ? cs.fontFamily.split(',')[0].replace(/["']/g, '').trim() : undefined;
	// 	  const fontSizePx = cs?.fontSize ? parseFloat(cs.fontSize) : undefined;
	// 	  const fontSizeHalfPoints = Number.isFinite(fontSizePx) ? Math.round((fontSizePx * 0.75) * 2) : undefined; // px->pt->halfPoints
	// 	  return { fontFamily, fontSizeHalfPoints };
	// 	};
	// 	const editorDefaults = readEditorDefaults();
	  
	// 	// Measure table column widths directly from the DOM so DOCX matches the editor UI
	// 	const measureTablesFromDOM = () => {
	// 	  const results = [];
	// 	  const rootEl = document.querySelector('.ContentEditable__root');
	// 	  if (!rootEl) return results;
	// 	  const tableEls = rootEl.querySelectorAll('table');
	// 	  tableEls.forEach((table) => {
	// 		try {
	// 		  const firstRow = table.rows && table.rows[0];
	// 		  if (!firstRow) {
	// 			results.push(null);
	// 			return;
	// 		  }
	// 		  const colWidthsPx = [];
	// 		  for (let ci = 0; ci < firstRow.cells.length; ci++) {
	// 			const rect = firstRow.cells[ci].getBoundingClientRect();
	// 			colWidthsPx.push(Math.max(0, Math.round(rect.width)));
	// 		  }
	// 		  const totalPx = colWidthsPx.reduce((a, b) => a + b, 0);
	// 		  const pxToTwips = (px) => Math.max(0, Math.round(px * 15)); // 1px≈1/96in; 1in=1440 twips => 1440/96=15
	// 		  const colsTwips = colWidthsPx.map(pxToTwips);
	// 		  const totalTwips = pxToTwips(totalPx);
	// 		  results.push({ colsTwips, totalTwips });
	// 		} catch (e) {
	// 		  results.push(null);
	// 		}
	// 	  });
	// 	  return results;
	// 	};
	  
	// 	const measuredTables = measureTablesFromDOM();
	// 	let measuredTableIndex = 0;
	  
	// 	const parseStyleToObject = (styleString) => {
	// 	  const style = {};
	// 	  if (!styleString) return style;
	// 	  styleString.split(";").forEach((decl) => {
	// 		const [prop, val] = decl.split(":");
	// 		if (prop && val) {
	// 		  style[prop.trim()] = val.trim();
	// 		}
	// 	  });
	// 	  return style;
	// 	};
	  
	// 	const normalizeFontFamily = (family) => {
	// 	  if (!family) return undefined;
	// 	  const first = family.split(",")[0] || "";
	// 	  return first.replace(/["']/g, "").trim() || undefined;
	// 	};
	  
	// 	const cssSizeToHalfPoints = (size) => {
	// 	  if (!size) return undefined;
	// 	  const s = String(size).trim().toLowerCase();
	// 	  if (s.endsWith("pt")) {
	// 		const pt = parseFloat(s);
	// 		return Number.isFinite(pt) ? Math.round(pt * 2) : undefined;
	// 	  }
	// 	  if (s.endsWith("px")) {
	// 		const px = parseFloat(s);
	// 		if (!Number.isFinite(px)) return undefined;
	// 		const pt = px * 0.75; // 1pt = 1.333px => pt = px * 0.75
	// 		return Math.round(pt * 2);
	// 	  }
	// 	  return undefined;
	// 	};
	  
	// 	const colorToHexNoHash = (c) => {
	// 	  if (!c) return undefined;
	// 	  const m = c.trim();
	// 	  if (m.startsWith("#")) return m.slice(1).toUpperCase();
	// 	  return m.toUpperCase();
	// 	};
	  
	// 	const cssLineHeightToDocxLine = (lineHeight, fallbackHalfPoints) => {
	// 	  if (!lineHeight) return undefined;
	// 	  const s = String(lineHeight).trim().toLowerCase();
	// 	  if (s.endsWith('%')) {
	// 		const pct = parseFloat(s);
	// 		if (Number.isFinite(pct)) return Math.round((pct / 100) * 240);
	// 	  }
	// 	  const num = parseFloat(s);
	// 	  if (Number.isFinite(num) && !s.endsWith('px') && !s.endsWith('pt')) {
	// 		return Math.round(num * 240); // 1.0 -> 240
	// 	  }
	// 	  let linePt;
	// 	  if (s.endsWith('pt')) {
	// 		linePt = parseFloat(s);
	// 	  } else if (s.endsWith('px')) {
	// 		const px = parseFloat(s);
	// 		linePt = Number.isFinite(px) ? px * 0.75 : undefined;
	// 	  }
	// 	  if (Number.isFinite(linePt)) {
	// 		const fontPt = fallbackHalfPoints ? fallbackHalfPoints / 2 : 11; // default ~11pt
	// 		const mult = linePt / fontPt;
	// 		return Math.round(mult * 240);
	// 	  }
	// 	  return undefined;
	// 	};
	  
	// 	editorState.read(() => {
	// 	  const root = $getRoot();
	  
	// 	  const collectRunsFromNode = (node, linkMeta) => {
	// 		const runs = [];
	// 		const type = node.getType();
	// 		if (type === "text") {
	// 		  const text = node.getTextContent();
	// 		  if (text && text.length > 0) {
	// 			const styleObj = parseStyleToObject(node.getStyle && node.getStyle());
	// 			const color = colorToHexNoHash(styleObj["color"]);
	// 			const bgColor = colorToHexNoHash(styleObj["background-color"]);
	// 			const fontFamily = normalizeFontFamily(styleObj["font-family"]) || editorDefaults.fontFamily;
	// 			const fontSize = cssSizeToHalfPoints(styleObj["font-size"]) || editorDefaults.fontSizeHalfPoints;
	// 			runs.push({
	// 			  kind: "text",
	// 			  text,
	// 			  bold: node.hasFormat("bold"),
	// 			  italics: node.hasFormat("italic"),
	// 			  underline: node.hasFormat("underline"),
	// 			  strike: node.hasFormat("strikethrough"),
	// 			  code: node.hasFormat("code"),
	// 			  color,
	// 			  bgColor,
	// 			  fontFamily,
	// 			  fontSize,
	// 			  isLink: linkMeta?.isLink || false,
	// 			  url: linkMeta?.url,
	// 			});
	// 		  }
	// 		} else if (type === "linebreak") {
	// 		  runs.push({ kind: "break" });
	// 		} else if (type === "link") {
	// 		  const url = node.getURL && node.getURL();
	// 		  node.getChildren().forEach((child) => {
	// 			runs.push(...collectRunsFromNode(child, { isLink: true, url }));
	// 		  });
	// 		} else if (type === "image") {
	// 		  const styleObj = parseStyleToObject(node.getStyle && node.getStyle());
	// 		  const widthPx = cssSizeToHalfPoints(styleObj["width"]) || 300;
	// 		  const heightPx = cssSizeToHalfPoints(styleObj["height"]) || 300;
	// 		  runs.push({ kind: "image", src: node.getSrc && node.getSrc(), width: widthPx, height: heightPx });
	// 		} else {
	// 		  if (node.getChildren) {
	// 			node.getChildren().forEach((child) => {
	// 			  runs.push(...collectRunsFromNode(child, linkMeta));
	// 			});
	// 		  }
	// 		}
	// 		return runs;
	// 	  };
	  
	// 	  root.getChildren().forEach((node) => {
	// 		const nodeType = node.getType();
	  
	// 		const nodeStyle = parseStyleToObject(node.getStyle && node.getStyle());
	// 		const paraLine = cssLineHeightToDocxLine(nodeStyle["line-height"], editorDefaults.fontSizeHalfPoints);
	// 		const beforeSpacing = cssSizeToHalfPoints(nodeStyle["margin-top"]) || (nodeType === "heading" ? 240 : 0);
	// 		const afterSpacing = cssSizeToHalfPoints(nodeStyle["margin-bottom"]) || 240;
	  
	// 		if (nodeType === "heading") {
	// 		  const tag = node.getTag && node.getTag();
	// 		  const runs = collectRunsFromNode(node);
	// 		  blocks.push({ kind: "heading", tag, runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
	// 		} else if (nodeType === "quote") {
	// 		  const runs = collectRunsFromNode(node);
	// 		  blocks.push({ kind: "quote", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
	// 		} else if (nodeType === "list") {
	// 		  const listTag = node.getTag && node.getTag();
	// 		  const items = node.getChildren();
	// 		  items.forEach((listItem, idx) => {
	// 			const runs = collectRunsFromNode(listItem);
	// 			blocks.push({
	// 			  kind: "list-item",
	// 			  ordered: listTag === "ol",
	// 			  index: idx,
	// 			  runs,
	// 			  align: node.getFormatType && node.getFormatType(),
	// 			  line: paraLine,
	// 			  before: beforeSpacing,
	// 			  after: afterSpacing,
	// 			});
	// 		  });
	// 		} else if (nodeType === "table") {
	// 		  const tableRows = [];
	// 		  const rowNodes = node.getChildren();
	// 		  rowNodes.forEach((rowNode) => {
	// 			const rowCells = [];
	// 			const cellNodes = rowNode.getChildren();
	// 			cellNodes.forEach((cellNode) => {
	// 			  const paraNodes = cellNode.getChildren();
	// 			  const paragraphs = [];
	// 			  if (Array.isArray(paraNodes) && paraNodes.length > 0) {
	// 				paraNodes.forEach((p) => {
	// 				  const pStyle = parseStyleToObject(p.getStyle && p.getStyle());
	// 				  const pLine = cssLineHeightToDocxLine(pStyle["line-height"], editorDefaults.fontSizeHalfPoints);
	// 				  const runs = collectRunsFromNode(p);
	// 				  paragraphs.push({ runs, align: p.getFormatType && p.getFormatType(), line: pLine });
	// 				});
	// 			  } else {
	// 				const runs = collectRunsFromNode(cellNode);
	// 				paragraphs.push({ runs, align: cellNode.getFormatType && cellNode.getFormatType(), line: paraLine });
	// 			  }
	// 			  rowCells.push({ paragraphs });
	// 			});
	// 			tableRows.push(rowCells);
	// 		  });
	// 		  const dims = measuredTables[measuredTableIndex++] || null;
	// 		  blocks.push({ kind: "table", rows: tableRows, dims });
	// 		} else if (nodeType === "paragraph") {
	// 		  const runs = collectRunsFromNode(node);
	// 		  blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
	// 		} else if (nodeType === "image") {
	// 		  const runs = collectRunsFromNode(node);
	// 		  blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
	// 		} else {
	// 		  const runs = collectRunsFromNode(node);
	// 		  if (runs.length > 0) {
	// 			blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
	// 		  }
	// 		}
	// 	  });
	// 	});
	  
	// 	const dataUrlToUint8Array = async (dataUrl) => {
	// 	  const res = await fetch(dataUrl);
	// 	  const blob = await res.blob();
	// 	  const ab = await blob.arrayBuffer();
	// 	  return new Uint8Array(ab);
	// 	};
	  
	// 	const loadImageElement = (src) => {
	// 	  return new Promise((resolve, reject) => {
	// 		const img = new Image();
	// 		img.onload = () => resolve(img);
	// 		img.onerror = (e) => reject(e);
	// 		img.src = src;
	// 	  });
	// 	};
	  
	// 	const convertImageToPngBytes = async (img) => {
	// 	  try {
	// 		const canvas = document.createElement("canvas");
	// 		canvas.width = img.naturalWidth || img.width || 1;
	// 		canvas.height = img.naturalHeight || img.height || 1;
	// 		const ctx = canvas.getContext("2d");
	// 		ctx.drawImage(img, 0, 0);
	// 		const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
	// 		if (!blob) return null;
	// 		const ab = await blob.arrayBuffer();
	// 		return new Uint8Array(ab);
	// 	  } catch (e) {
	// 		console.warn("PNG conversion failed", e);
	// 		return null;
	// 	  }
	// 	};
	  
	// 	const sniffImageType = (bytes) => {
	// 	  if (!bytes || bytes.length < 12) return null;
	// 	  if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47 && bytes[4] === 0x0d && bytes[5] === 0x0a && bytes[6] === 0x1a && bytes[7] === 0x0a) {
	// 		return "png";
	// 	  }
	// 	  if (bytes[0] === 0xff && bytes[1] === 0xd8) return "jpeg";
	// 	  if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38 && (bytes[4] === 0x39 || bytes[4] === 0x37) && bytes[5] === 0x61) {
	// 		return "gif";
	// 	  }
	// 	  return null;
	// 	};
	  
	// 	const tryBitmapToPng = async (blob) => {
	// 	  try {
	// 		if (typeof createImageBitmap === "function") {
	// 		  const bitmap = await createImageBitmap(blob);
	// 		  const canvas = document.createElement("canvas");
	// 		  canvas.width = bitmap.width || 1;
	// 		  canvas.height = bitmap.height || 1;
	// 		  const ctx = canvas.getContext("2d");
	// 		  ctx.drawImage(bitmap, 0, 0);
	// 		  const out = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
	// 		  if (!out) return null;
	// 		  const ab = await out.arrayBuffer();
	// 		  return new Uint8Array(ab);
	// 		}
	// 	  } catch (e) {
	// 		console.warn("Bitmap conversion failed", e);
	// 	  }
	// 	  return null;
	// 	};
	  
	// 	const resolveImage = async (src) => {
	// 	  if (!src) return null;
	// 	  let data;
	// 	  let width;
	// 	  let height;
	// 	  let type;
	  
	// 	  if (src.startsWith("data:")) {
	// 		try {
	// 		  const img = await loadImageElement(src);
	// 		  width = img.naturalWidth || 300;
	// 		  height = img.naturalHeight || 300;
	// 		  const png = await convertImageToPngBytes(img);
	// 		  if (png) {
	// 			data = png;
	// 			type = "png";
	// 		  } else {
	// 			data = await dataUrlToUint8Array(src);
	// 			type = sniffImageType(data) || "png";
	// 		  }
	// 		} catch (e) {
	// 		  console.warn("Failed to load data URL image for DOCX:", e);
	// 		  data = await dataUrlToUint8Array(src);
	// 		  type = sniffImageType(data) || "png";
	// 		  width = 300;
	// 		  height = 300;
	// 		}
	// 	  } else {
	// 		const res = await fetch(src, { mode: "cors" }).catch((e) => {
	// 		  console.warn("Image fetch failed due to CORS or network:", src, e);
	// 		  return null;
	// 		});
	// 		if (!res || !res.ok) return null;
	// 		const blob = await res.blob();
	// 		const objectUrl = URL.createObjectURL(blob);
	// 		try {
	// 		  const img = await loadImageElement(objectUrl);
	// 		  width = img.naturalWidth || 300;
	// 		  height = img.naturalHeight || 300;
	// 		  const png = await convertImageToPngBytes(img);
	// 		  if (png) {
	// 			data = png;
	// 			type = "png";
	// 		  } else {
	// 			const ab = await blob.arrayBuffer();
	// 			data = new Uint8Array(ab);
	// 			type = sniffImageType(data);
	// 			if (!type) {
	// 			  const conv = await tryBitmapToPng(blob);
	// 			  if (conv) {
	// 				data = conv;
	// 				type = "png";
	// 			  }
	// 			}
	// 		  }
	// 		} catch (e) {
	// 		  console.warn("Failed to load remote image into canvas, falling back to raw bytes", e);
	// 		  const ab = await blob.arrayBuffer();
	// 		  data = new Uint8Array(ab);
	// 		  type = sniffImageType(data);
	// 		  if (!type) {
	// 			const conv = await tryBitmapToPng(blob);
	// 			if (conv) {
	// 			  data = conv;
	// 			  type = "png";
	// 			}
	// 		  }
	// 		  width = 300;
	// 		  height = 300;
	// 		} finally {
	// 		  URL.revokeObjectURL(objectUrl);
	// 		}
	// 	  }
	  
	// 	  if (!data) return null;
	// 	  return { data, width, height, type: type || "png" };
	// 	};
	  
	// 	const mapAlign = (align) => {
	// 	  switch (align) {
	// 		case "center":
	// 		  return AlignmentType.CENTER;
	// 		case "right":
	// 		  return AlignmentType.RIGHT;
	// 		case "justify":
	// 		  return AlignmentType.JUSTIFIED;
	// 		default:
	// 		  return AlignmentType.LEFT;
	// 	  }
	// 	};
	  
	// 	const sectionChildren = [];
	  
	// 	const buildParagraphFromRuns = async (runs, align, line, before, after) => {
	// 	  const paraChildren = [];
	  
	// 	  const pushTextSegments = (run) => {
	// 		const baseOpts = {
	// 		  bold: !!run.bold,
	// 		  italics: !!run.italics,
	// 		  underline: run.underline || run.isLink ? {} : undefined,
	// 		  strike: !!run.strike,
	// 		  color: run.isLink ? "0000FF" : run.color,
	// 		  font: run.code ? "Courier New" : run.fontFamily,
	// 		  size: run.fontSize,
	// 		  shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
	// 		};
	// 		const text = run.text || "";
	// 		const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
	// 		const lines = text.split("\n");
	// 		lines.forEach((lineText, li) => {
	// 		  const parts = lineText.split("\t");
	// 		  parts.forEach((part, pi) => {
	// 			const t = normalizeSpaces(part);
	// 			const tr = new TextRun({ text: t, ...baseOpts });
	// 			if (run.isLink && run.url) {
	// 			  paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
	// 			} else {
	// 			  paraChildren.push(tr);
	// 			}
	// 			if (pi < parts.length - 1) {
	// 			  paraChildren.push(new TextRun({ text: "\t" }));
	// 			}
	// 		  });
	// 		  if (li < lines.length - 1) {
	// 			paraChildren.push(new TextRun({ break: 1 }));
	// 		  }
	// 		});
	// 	  };
	  
	// 	  if (Array.isArray(runs)) {
	// 		for (const run of runs) {
	// 		  if (run.kind === "image") {
	// 			const img = await resolveImage(run.src);
	// 			if (img) {
	// 			  paraChildren.push(
	// 				new ImageRun({ 
	// 				  data: img.data, 
	// 				  transformation: { width: run.width || img.width || 300, height: run.height || img.height || 300 }, 
	// 				  type: img.type 
	// 				})
	// 			  );
	// 			}
	// 		  } else if (run.kind === "break") {
	// 			paraChildren.push(new TextRun({ break: 1 }));
	// 		  } else if (run.kind === "text") {
	// 			pushTextSegments(run);
	// 		  }
	// 		}
	// 	  }
	  
	// 	  return new Paragraph({ 
	// 		alignment: mapAlign(align), 
	// 		spacing: { before, after, line: line || 240 }, 
	// 		children: paraChildren 
	// 	  });
	// 	};
	  
	// 	for (const block of blocks) {
	// 	  if (block.kind === "list-item") {
	// 		const childrenRuns = [];
	// 		if (block.ordered) {
	// 		  childrenRuns.push(new TextRun({ text: `${(block.index || 0) + 1}. ` }));
	// 		} else {
	// 		  childrenRuns.push(new TextRun({ text: "• " }));
	// 		}
	// 		for (const run of block.runs) {
	// 		  if (run.kind === "image") {
	// 			const img = await resolveImage(run.src);
	// 			if (img) {
	// 			  childrenRuns.push(
	// 				new ImageRun({ 
	// 				  data: img.data, 
	// 				  transformation: { width: run.width || img.width || 300, height: run.height || img.height || 300 }, 
	// 				  type: img.type 
	// 				})
	// 			  );
	// 			}
	// 		  } else if (run.kind === "break") {
	// 			childrenRuns.push(new TextRun({ break: 1 }));
	// 		  } else if (run.kind === "text") {
	// 			const baseOpts = {
	// 			  bold: !!run.bold,
	// 			  italics: !!run.italics,
	// 			  underline: run.underline ? {} : undefined,
	// 			  strike: !!run.strike,
	// 			  color: run.isLink ? "0000FF" : run.color,
	// 			  font: run.code ? "Courier New" : run.fontFamily,
	// 			  size: run.fontSize,
	// 			  shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
	// 			};
	// 			const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
	// 			const lines = (run.text || "").split("\n");
	// 			lines.forEach((lineText, li) => {
	// 			  const parts = lineText.split("\t");
	// 			  parts.forEach((part, pi) => {
	// 				const t = normalizeSpaces(part);
	// 				const tr = new TextRun({ text: t, ...baseOpts });
	// 				if (run.isLink && run.url) {
	// 				  childrenRuns.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
	// 				} else {
	// 				  childrenRuns.push(tr);
	// 				}
	// 				if (pi < parts.length - 1) {
	// 				  childrenRuns.push(new TextRun({ text: "\t" }));
	// 				}
	// 			  });
	// 			  if (li < lines.length - 1) {
	// 				childrenRuns.push(new TextRun({ break: 1 }));
	// 			  }
	// 			});
	// 		  }
	// 		}
	// 		sectionChildren.push(
	// 		  new Paragraph({ 
	// 			alignment: mapAlign(block.align), 
	// 			spacing: { before: block.before || 0, after: block.after || 120, line: block.line || 240 }, 
	// 			children: childrenRuns 
	// 		  })
	// 		);
	// 		continue;
	// 	  }
	  
	// 	  if (block.kind === "table") {
	// 		const rows = [];
	// 		const pageContentWidthTwips = 9360; // ~6.5 inches
	  
	// 		let columnWidths = [];
	// 		let tableWidthTwips = pageContentWidthTwips;
	// 		if (block.dims && Array.isArray(block.dims.colsTwips)) {
	// 		  const sum = block.dims.colsTwips.reduce((a, b) => a + b, 0) || 0;
	// 		  if (sum > 0) {
	// 			const scale = sum > pageContentWidthTwips ? pageContentWidthTwips / sum : 1;
	// 			columnWidths = block.dims.colsTwips.map((w) => Math.max(0, Math.floor(w * scale)));
	// 			tableWidthTwips = Math.min(pageContentWidthTwips, Math.max(0, Math.floor(sum * scale)));
	// 		  }
	// 		}
	  
	// 		if (!columnWidths.length) {
	// 		  const colsCount = (block.rows && block.rows[0] ? block.rows[0].length : 0) || 0;
	// 		  if (colsCount === 3) {
	// 			columnWidths = [2200, 2200, pageContentWidthTwips - 2200 - 2200];
	// 		  } else if (colsCount > 0) {
	// 			const each = Math.floor(pageContentWidthTwips / colsCount);
	// 			columnWidths = new Array(colsCount).fill(each);
	// 		  }
	// 		}
	  
	// 		for (const rowCells of block.rows) {
	// 		  const cells = [];
	// 		  for (let ci = 0; ci < rowCells.length; ci++) {
	// 			const cell = rowCells[ci];
	// 			const cellParagraphs = [];
	// 			for (const p of cell.paragraphs) {
	// 			  cellParagraphs.push(
	// 				await buildParagraphFromRuns(p.runs, p.align, p.line, 0, p.line && p.runs.some(r => (r.text || '').split('\n').length > 1) ? 60 : 120) // Reduced after spacing
	// 			  );
	// 			}
	// 			cells.push(
	// 			  new TableCell({
	// 				children: cellParagraphs,
	// 				width: columnWidths.length ? { size: columnWidths[ci] || columnWidths[0], type: WidthType.DXA } : undefined,
	// 				margins: { top: 100, bottom: 100, left: 120, right: 120 }, // Reduced top and bottom margins
	// 			  })
	// 			);
	// 		  }
	// 		  rows.push(new TableRow({ children: cells }));
	// 		}
	// 		sectionChildren.push(
	// 		  new Table({
	// 			width: { size: tableWidthTwips, type: WidthType.DXA },
	// 			columnWidths: columnWidths.length ? columnWidths : undefined,
	// 			alignment: AlignmentType.CENTER,
	// 			layout: TableLayoutType.FIXED,
	// 			rows,
	// 			borders: {
	// 			  top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 			  bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 			  left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 			  right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 			  insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 			  insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
	// 			},
	// 		  })
	// 		);
	// 		continue;
	// 	  }
	  
	// 	  if (block.kind === "heading" || block.kind === "quote" || block.kind === "paragraph") {
	// 		const paraChildren = [];
	// 		if (Array.isArray(block.runs)) {
	// 		  for (const run of block.runs) {
	// 			if (run.kind === "image") {
	// 			  const img = await resolveImage(run.src);
	// 			  if (img) {
	// 				paraChildren.push(
	// 				  new ImageRun({ 
	// 					data: img.data, 
	// 					transformation: { width: run.width || img.width || 300, height: run.height || img.height || 300 }, 
	// 					type: img.type 
	// 				  })
	// 				);
	// 			  }
	// 			} else if (run.kind === "break") {
	// 			  paraChildren.push(new TextRun({ break: 1 }));
	// 			} else if (run.kind === "text") {
	// 			  const baseOpts = {
	// 				bold: !!run.bold,
	// 				italics: !!run.italics,
	// 				underline: run.underline || run.isLink ? {} : undefined,
	// 				strike: !!run.strike,
	// 				color: run.isLink ? "0000FF" : run.color,
	// 				font: run.code ? "Courier New" : run.fontFamily,
	// 				size: run.fontSize,
	// 				shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
	// 			  };
	// 			  const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
	// 			  const lines = (run.text || "").split("\n");
	// 			  lines.forEach((lineText, li) => {
	// 				const parts = lineText.split("\t");
	// 				parts.forEach((part, pi) => {
	// 				  const t = normalizeSpaces(part);
	// 				  const tr = new TextRun({ text: t, ...baseOpts });
	// 				  if (run.isLink && run.url) {
	// 					paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
	// 				  } else {
	// 					paraChildren.push(tr);
	// 				  }
	// 				  if (pi < parts.length - 1) {
	// 					paraChildren.push(new TextRun({ text: "\t" }));
	// 				  }
	// 				});
	// 				if (li < lines.length - 1) {
	// 				  paraChildren.push(new TextRun({ break: 1 }));
	// 				}
	// 			  });
	// 			}
	// 		  }
	// 		}
	  
	// 		let paragraph;
	// 		if (block.kind === "heading") {
	// 		  const headingLevel = block.tag === "h1" ? HeadingLevel.HEADING_1 : block.tag === "h2" ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3;
	// 		  paragraph = new Paragraph({ 
	// 			heading: headingLevel, 
	// 			alignment: mapAlign(block.align), 
	// 			spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
	// 			children: paraChildren 
	// 		  });
	// 		} else if (block.kind === "quote") {
	// 		  paragraph = new Paragraph({ 
	// 			alignment: mapAlign(block.align), 
	// 			spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
	// 			children: [new TextRun({ text: "“" }), ...paraChildren, new TextRun({ text: "”" })] 
	// 		  });
	// 		} else {
	// 		  paragraph = new Paragraph({ 
	// 			alignment: mapAlign(block.align), 
	// 			spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
	// 			children: paraChildren 
	// 		  });
	// 		}
	// 		sectionChildren.push(paragraph);
	// 	  }
	// 	}
	  
	// 	const doc = new Document({
	// 	  sections: [
	// 		{
	// 		  properties: {
	// 			page: {
	// 			  margin: {
	// 				top: 720,    // 0.5 inch = 720 twips
	// 				right: 720,  // 0.5 inch = 720 twips
	// 				bottom: 720, // 0.5 inch = 720 twips
	// 				left: 720,   // 0.5 inch = 720 twips
	// 			  }
	// 			}
	// 		  },
	// 		  children: sectionChildren,
	// 		},
	// 	  ],
	// 	});
	  
	// 	const blob = await Packer.toBlob(doc);
	// 	saveAs(blob, "document.docx");
	//   };

// 	const handleDownloadDocx = async (editor) => {
//     const editorState = editor.getEditorState();
//     const blocks = [];
  
//     // Capture editor-level default font family and size from DOM
//     const readEditorDefaults = () => {
//       const rootEl = document.querySelector('.ContentEditable__root');
//       const cs = rootEl ? window.getComputedStyle(rootEl) : null;
//       const fontFamily = cs?.fontFamily ? cs.fontFamily.split(',')[0].replace(/["']/g, '').trim() : undefined;
//       const fontSizePx = cs?.fontSize ? parseFloat(cs.fontSize) : undefined;
//       const fontSizeHalfPoints = Number.isFinite(fontSizePx) ? Math.round((fontSizePx * 0.75) * 2) : undefined; // px->pt->halfPoints
//       return { fontFamily, fontSizeHalfPoints };
//     };
//     const editorDefaults = readEditorDefaults();
  
//     // Measure table column widths directly from the DOM so DOCX matches the editor UI
//     const measureTablesFromDOM = () => {
//       const results = [];
//       const rootEl = document.querySelector('.ContentEditable__root');
//       if (!rootEl) return results;
//       const tableEls = rootEl.querySelectorAll('table');
//       tableEls.forEach((table) => {
//         try {
//           const firstRow = table.rows && table.rows[0];
//           if (!firstRow) {
//             results.push(null);
//             return;
//           }
//           const colWidthsPx = [];
//           for (let ci = 0; ci < firstRow.cells.length; ci++) {
//             const rect = firstRow.cells[ci].getBoundingClientRect();
//             colWidthsPx.push(Math.max(0, Math.round(rect.width)));
//           }
//           const totalPx = colWidthsPx.reduce((a, b) => a + b, 0);
//           const pxToTwips = (px) => Math.max(0, Math.round(px * 15)); // 1px≈1/96in; 1in=1440 twips => 1440/96=15
//           const colsTwips = colWidthsPx.map(pxToTwips);
//           const totalTwips = pxToTwips(totalPx);
//           results.push({ colsTwips, totalTwips });
//         } catch (e) {
//           results.push(null);
//         }
//       });
//       return results;
//     };
  
//     const measuredTables = measureTablesFromDOM();
//     let measuredTableIndex = 0;
  
//     const parseStyleToObject = (styleString) => {
//       const style = {};
//       if (!styleString) return style;
//       styleString.split(";").forEach((decl) => {
//         const [prop, val] = decl.split(":");
//         if (prop && val) {
//           style[prop.trim()] = val.trim();
//         }
//       });
//       return style;
//     };
  
//     const normalizeFontFamily = (family) => {
//       if (!family) return undefined;
//       const first = family.split(",")[0] || "";
//       return first.replace(/["']/g, "").trim() || undefined;
//     };
  
//     const cssSizeToHalfPoints = (size) => {
//       if (!size) return undefined;
//       const s = String(size).trim().toLowerCase();
//       if (s.endsWith("pt")) {
//         const pt = parseFloat(s);
//         return Number.isFinite(pt) ? Math.round(pt * 2) : undefined;
//       }
//       if (s.endsWith("px")) {
//         const px = parseFloat(s);
//         if (!Number.isFinite(px)) return undefined;
//         const pt = px * 0.75; // 1pt = 1.333px => pt = px * 0.75
//         return Math.round(pt * 2);
//       }
//       return undefined;
//     };
  
//     const colorToHexNoHash = (c) => {
//       if (!c) return undefined;
//       const m = c.trim();
//       if (m.startsWith("#")) return m.slice(1).toUpperCase();
//       return m.toUpperCase();
//     };
  
//     const cssLineHeightToDocxLine = (lineHeight, fallbackHalfPoints) => {
//       if (!lineHeight) return undefined;
//       const s = String(lineHeight).trim().toLowerCase();
//       if (s.endsWith('%')) {
//         const pct = parseFloat(s);
//         if (Number.isFinite(pct)) return Math.round((pct / 100) * 240);
//       }
//       const num = parseFloat(s);
//       if (Number.isFinite(num) && !s.endsWith('px') && !s.endsWith('pt')) {
//         return Math.round(num * 240); // 1.0 -> 240
//       }
//       let linePt;
//       if (s.endsWith('pt')) {
//         linePt = parseFloat(s);
//       } else if (s.endsWith('px')) {
//         const px = parseFloat(s);
//         linePt = Number.isFinite(px) ? px * 0.75 : undefined;
//       }
//       if (Number.isFinite(linePt)) {
//         const fontPt = fallbackHalfPoints ? fallbackHalfPoints / 2 : 11; // default ~11pt
//         const mult = linePt / fontPt;
//         return Math.round(mult * 240);
//       }
//       return undefined;
//     };
  
//     editorState.read(() => {
//       const root = $getRoot();
  
//       const collectRunsFromNode = (node, linkMeta) => {
//         const runs = [];
//         const type = node.getType();
//         if (type === "text") {
//           const text = node.getTextContent();
//           if (text && text.length > 0) {
//             const styleObj = parseStyleToObject(node.getStyle && node.getStyle());
//             const color = colorToHexNoHash(styleObj["color"]);
//             const bgColor = colorToHexNoHash(styleObj["background-color"]);
//             const fontFamily = normalizeFontFamily(styleObj["font-family"]) || editorDefaults.fontFamily;
//             const fontSize = cssSizeToHalfPoints(styleObj["font-size"]) || editorDefaults.fontSizeHalfPoints;
//             runs.push({
//               kind: "text",
//               text,
//               bold: node.hasFormat("bold"),
//               italics: node.hasFormat("italic"),
//               underline: node.hasFormat("underline"),
//               strike: node.hasFormat("strikethrough"),
//               code: node.hasFormat("code"),
//               color,
//               bgColor,
//               fontFamily,
//               fontSize,
//               isLink: linkMeta?.isLink || false,
//               url: linkMeta?.url,
//             });
//           }
//         } else if (type === "linebreak") {
//           runs.push({ kind: "break" });
//         } else if (type === "link") {
//           const url = node.getURL && node.getURL();
//           node.getChildren().forEach((child) => {
//             runs.push(...collectRunsFromNode(child, { isLink: true, url }));
//           });
//         } else if (type === "image") {
//           const styleObj = parseStyleToObject(node.getStyle && node.getStyle());
//           const widthPx = cssSizeToHalfPoints(styleObj["width"]) || 300;
//           const heightPx = cssSizeToHalfPoints(styleObj["height"]) || 300;
//           runs.push({ kind: "image", src: node.getSrc && node.getSrc(), width: widthPx, height: heightPx });
//         } else {
//           if (node.getChildren) {
//             node.getChildren().forEach((child) => {
//               runs.push(...collectRunsFromNode(child, linkMeta));
//             });
//           }
//         }
//         return runs;
//       };
  
//       root.getChildren().forEach((node) => {
//         const nodeType = node.getType();
  
//         const nodeStyle = parseStyleToObject(node.getStyle && node.getStyle());
//         const paraLine = cssLineHeightToDocxLine(nodeStyle["line-height"], editorDefaults.fontSizeHalfPoints);
        
//         // Use consistent spacing for all elements to ensure alignment
//         const beforeSpacing = 60; // Reduced from 240 to 120 for consistent spacing
//         const afterSpacing = 60;  // Reduced from 240 to 120 for consistent spacing
  
//         if (nodeType === "heading") {
//           const tag = node.getTag && node.getTag();
//           const runs = collectRunsFromNode(node);
//           blocks.push({ kind: "heading", tag, runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//         } else if (nodeType === "quote") {
//           const runs = collectRunsFromNode(node);
//           blocks.push({ kind: "quote", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//         } else if (nodeType === "list") {
//           const listTag = node.getTag && node.getTag();
//           const items = node.getChildren();
//           items.forEach((listItem, idx) => {
//             const runs = collectRunsFromNode(listItem);
//             blocks.push({
//               kind: "list-item",
//               ordered: listTag === "ol",
//               index: idx,
//               runs,
//               align: node.getFormatType && node.getFormatType(),
//               line: paraLine,
//               before: beforeSpacing,
//               after: afterSpacing,
//             });
//           });
//         } else if (nodeType === "table") {
//           const tableRows = [];
//           const rowNodes = node.getChildren();
//           rowNodes.forEach((rowNode) => {
//             const rowCells = [];
//             const cellNodes = rowNode.getChildren();
//             cellNodes.forEach((cellNode) => {
//               const paraNodes = cellNode.getChildren();
//               const paragraphs = [];
//               if (Array.isArray(paraNodes) && paraNodes.length > 0) {
//                 paraNodes.forEach((p) => {
//                   const pStyle = parseStyleToObject(p.getStyle && p.getStyle());
//                   const pLine = cssLineHeightToDocxLine(pStyle["line-height"], editorDefaults.fontSizeHalfPoints);
//                   const runs = collectRunsFromNode(p);
//                   paragraphs.push({ runs, align: p.getFormatType && p.getFormatType(), line: pLine });
//                 });
//               } else {
//                 const runs = collectRunsFromNode(cellNode);
//                 paragraphs.push({ runs, align: cellNode.getFormatType && cellNode.getFormatType(), line: paraLine });
//               }
//               rowCells.push({ paragraphs });
//             });
//             tableRows.push(rowCells);
//           });
//           const dims = measuredTables[measuredTableIndex++] || null;
//           blocks.push({ 
//             kind: "table", 
//             rows: tableRows, 
//             dims,
//             before: beforeSpacing, // Add consistent before spacing for tables
//             after: afterSpacing    // Add consistent after spacing for tables
//           });
//         } else if (nodeType === "paragraph") {
//           const runs = collectRunsFromNode(node);
//           blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//         } else if (nodeType === "image") {
//           const runs = collectRunsFromNode(node);
//           blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//         } else {
//           const runs = collectRunsFromNode(node);
//           if (runs.length > 0) {
//             blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//           }
//         }
//       });
//     });
  
//     const dataUrlToUint8Array = async (dataUrl) => {
//       const res = await fetch(dataUrl);
//       const blob = await res.blob();
//       const ab = await blob.arrayBuffer();
//       return new Uint8Array(ab);
//     };
  
//     const loadImageElement = (src) => {
//       return new Promise((resolve, reject) => {
//         const img = new Image();
//         img.onload = () => resolve(img);
//         img.onerror = (e) => reject(e);
//         img.src = src;
//       });
//     };
  
//     const convertImageToPngBytes = async (img) => {
//       try {
//         const canvas = document.createElement("canvas");
//         canvas.width = img.naturalWidth || img.width || 1;
//         canvas.height = img.naturalHeight || img.height || 1;
//         const ctx = canvas.getContext("2d");
//         ctx.drawImage(img, 0, 0);
//         const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
//         if (!blob) return null;
//         const ab = await blob.arrayBuffer();
//         return new Uint8Array(ab);
//       } catch (e) {
//         console.warn("PNG conversion failed", e);
//         return null;
//       }
//     };
  
//     const sniffImageType = (bytes) => {
//       if (!bytes || bytes.length < 12) return null;
//       if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47 && bytes[4] === 0x0d && bytes[5] === 0x0a && bytes[6] === 0x1a && bytes[7] === 0x0a) {
//         return "png";
//       }
//       if (bytes[0] === 0xff && bytes[1] === 0xd8) return "jpeg";
//       if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38 && (bytes[4] === 0x39 || bytes[4] === 0x37) && bytes[5] === 0x61) {
//         return "gif";
//       }
//       return null;
//     };
  
//     const tryBitmapToPng = async (blob) => {
//       try {
//         if (typeof createImageBitmap === "function") {
//           const bitmap = await createImageBitmap(blob);
//           const canvas = document.createElement("canvas");
//           canvas.width = bitmap.width || 1;
//           canvas.height = bitmap.height || 1;
//           const ctx = canvas.getContext("2d");
//           ctx.drawImage(bitmap, 0, 0);
//           const out = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
//           if (!out) return null;
//           const ab = await out.arrayBuffer();
//           return new Uint8Array(ab);
//         }
//       } catch (e) {
//         console.warn("Bitmap conversion failed", e);
//       }
//       return null;
//     };
  
//     const resolveImage = async (src) => {
//       if (!src) return null;
//       let data;
//       let width;
//       let height;
//       let type;
  
//       if (src.startsWith("data:")) {
//         try {
//           const img = await loadImageElement(src);
//           width = img.naturalWidth || 300;
//           height = img.naturalHeight || 300;
//           const png = await convertImageToPngBytes(img);
//           if (png) {
//             data = png;
//             type = "png";
//           } else {
//             data = await dataUrlToUint8Array(src);
//             type = sniffImageType(data) || "png";
//           }
//         } catch (e) {
//           console.warn("Failed to load data URL image for DOCX:", e);
//           data = await dataUrlToUint8Array(src);
//           type = sniffImageType(data) || "png";
//           width = 300;
//           height = 300;
//         }
//       } else {
//         const res = await fetch(src, { mode: "cors" }).catch((e) => {
//           console.warn("Image fetch failed due to CORS or network:", src, e);
//           return null;
//         });
//         if (!res || !res.ok) return null;
//         const blob = await res.blob();
//         const objectUrl = URL.createObjectURL(blob);
//         try {
//           const img = await loadImageElement(objectUrl);
//           width = img.naturalWidth || 300;
//           height = img.naturalHeight || 300;
//           const png = await convertImageToPngBytes(img);
//           if (png) {
//             data = png;
//             type = "png";
//           } else {
//             const ab = await blob.arrayBuffer();
//             data = new Uint8Array(ab);
//             type = sniffImageType(data);
//             if (!type) {
//               const conv = await tryBitmapToPng(blob);
//               if (conv) {
//                 data = conv;
//                 type = "png";
//               }
//             }
//           }
//         } catch (e) {
//           console.warn("Failed to load remote image into canvas, falling back to raw bytes", e);
//           const ab = await blob.arrayBuffer();
//           data = new Uint8Array(ab);
//           type = sniffImageType(data);
//           if (!type) {
//             const conv = await tryBitmapToPng(blob);
//             if (conv) {
//               data = conv;
//               type = "png";
//             }
//           }
//           width = 300;
//           height = 300;
//         } finally {
//           URL.revokeObjectURL(objectUrl);
//         }
//       }
  
//       if (!data) return null;
//       return { data, width, height, type: type || "png" };
//     };
  
//     const mapAlign = (align) => {
//       switch (align) {
//         case "center":
//           return AlignmentType.CENTER;
//         case "right":
//           return AlignmentType.RIGHT;
//         case "justify":
//           return AlignmentType.JUSTIFIED;
//         default:
//           return AlignmentType.LEFT;
//       }
//     };
  
//     const sectionChildren = [];
  
//     const buildParagraphFromRuns = async (runs, align, line, before, after) => {
//       const paraChildren = [];
  
//       const pushTextSegments = (run) => {
//         const baseOpts = {
//           bold: !!run.bold,
//           italics: !!run.italics,
//           underline: run.underline || run.isLink ? {} : undefined,
//           strike: !!run.strike,
//           color: run.isLink ? "0000FF" : run.color,
//           font: run.code ? "Courier New" : run.fontFamily,
//           size: run.fontSize,
//           shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
//         };
//         const text = run.text || "";
//         const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
//         const lines = text.split("\n");
//         lines.forEach((lineText, li) => {
//           const parts = lineText.split("\t");
//           parts.forEach((part, pi) => {
//             const t = normalizeSpaces(part);
//             const tr = new TextRun({ text: t, ...baseOpts });
//             if (run.isLink && run.url) {
//               paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
//             } else {
//               paraChildren.push(tr);
//             }
//             if (pi < parts.length - 1) {
//               paraChildren.push(new TextRun({ text: "\t" }));
//             }
//           });
//           if (li < lines.length - 1) {
//             paraChildren.push(new TextRun({ break: 1 }));
//           }
//         });
//       };
  
//       if (Array.isArray(runs)) {
//         for (const run of runs) {
//           if (run.kind === "image") {
//             const img = await resolveImage(run.src);
//             if (img) {
//               paraChildren.push(
//                 new ImageRun({ 
//                   data: img.data, 
//                   transformation: { width: run.width || img.width || 300, height: run.height || img.height || 300 }, 
//                   type: img.type 
//                 })
//               );
//             }
//           } else if (run.kind === "break") {
//             paraChildren.push(new TextRun({ break: 1 }));
//           } else if (run.kind === "text") {
//             pushTextSegments(run);
//           }
//         }
//       }
  
//       return new Paragraph({ 
//         alignment: mapAlign(align), 
//         spacing: { before, after, line: line || 240 }, 
//         children: paraChildren 
//       });
//     };
  
//     for (const block of blocks) {
//       if (block.kind === "list-item") {
//         const childrenRuns = [];
//         if (block.ordered) {
//           childrenRuns.push(new TextRun({ text: `${(block.index || 0) + 1}. ` }));
//         } else {
//           childrenRuns.push(new TextRun({ text: "• " }));
//         }
//         for (const run of block.runs) {
//           if (run.kind === "image") {
//             const img = await resolveImage(run.src);
//             if (img) {
//               childrenRuns.push(
//                 new ImageRun({ 
//                   data: img.data, 
//                   transformation: { width: run.width || img.width || 300, height: run.height || img.height || 300 }, 
//                   type: img.type 
//                 })
//               );
//             }
//           } else if (run.kind === "break") {
//             childrenRuns.push(new TextRun({ break: 1 }));
//           } else if (run.kind === "text") {
//             const baseOpts = {
//               bold: !!run.bold,
//               italics: !!run.italics,
//               underline: run.underline ? {} : undefined,
//               strike: !!run.strike,
//               color: run.isLink ? "0000FF" : run.color,
//               font: run.code ? "Courier New" : run.fontFamily,
//               size: run.fontSize,
//               shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
//             };
//             const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
//             const lines = (run.text || "").split("\n");
//             lines.forEach((lineText, li) => {
//               const parts = lineText.split("\t");
//               parts.forEach((part, pi) => {
//                 const t = normalizeSpaces(part);
//                 const tr = new TextRun({ text: t, ...baseOpts });
//                 if (run.isLink && run.url) {
//                   childrenRuns.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
//                 } else {
//                   childrenRuns.push(tr);
//                 }
//                 if (pi < parts.length - 1) {
//                   childrenRuns.push(new TextRun({ text: "\t" }));
//                 }
//               });
//               if (li < lines.length - 1) {
//                 childrenRuns.push(new TextRun({ break: 1 }));
//               }
//             });
//           }
//         }
//         sectionChildren.push(
//           new Paragraph({ 
//             alignment: mapAlign(block.align), 
//             spacing: { before: block.before || 120, after: block.after || 120, line: block.line || 240 }, 
//             children: childrenRuns 
//           })
//         );
//         continue;
//       }
  
//       if (block.kind === "table") {
//         const rows = [];
//         const pageContentWidthTwips = 9360; // ~6.5 inches
  
//         let columnWidths = [];
//         let tableWidthTwips = pageContentWidthTwips;
//         if (block.dims && Array.isArray(block.dims.colsTwips)) {
//           const sum = block.dims.colsTwips.reduce((a, b) => a + b, 0) || 0;
//           if (sum > 0) {
//             const scale = sum > pageContentWidthTwips ? pageContentWidthTwips / sum : 1;
//             columnWidths = block.dims.colsTwips.map((w) => Math.max(0, Math.floor(w * scale)));
//             tableWidthTwips = Math.min(pageContentWidthTwips, Math.max(0, Math.floor(sum * scale)));
//           }
//         }
  
//         if (!columnWidths.length) {
//           const colsCount = (block.rows && block.rows[0] ? block.rows[0].length : 0) || 0;
//           if (colsCount === 3) {
//             columnWidths = [2200, 2200, pageContentWidthTwips - 2200 - 2200];
//           } else if (colsCount > 0) {
//             const each = Math.floor(pageContentWidthTwips / colsCount);
//             columnWidths = new Array(colsCount).fill(each);
//           }
//         }
  
//         for (const rowCells of block.rows) {
//           const cells = [];
//           for (let ci = 0; ci < rowCells.length; ci++) {
//             const cell = rowCells[ci];
//             const cellParagraphs = [];
//             for (const p of cell.paragraphs) {
//               cellParagraphs.push(
//                 await buildParagraphFromRuns(p.runs, p.align, p.line, 0, 120)
//               );
//             }
//             cells.push(
//               new TableCell({
//                 children: cellParagraphs,
//                 width: columnWidths.length ? { size: columnWidths[ci] || columnWidths[0], type: WidthType.DXA } : undefined,
//                 margins: { top: 100, bottom: 100, left: 120, right: 120 },
//               })
//             );
//           }
//           rows.push(new TableRow({ children: cells }));
//         }
        
//         // Add spacing before the table to match headings
//         if (block.before && block.before > 0) {
//           sectionChildren.push(new Paragraph({
//             children: [],
//             spacing: { before: 0, after: block.before }
//           }));
//         }
        
//         sectionChildren.push(
//           new Table({
//             width: { size: tableWidthTwips, type: WidthType.DXA },
//             columnWidths: columnWidths.length ? columnWidths : undefined,
//             alignment: AlignmentType.CENTER,
//             layout: TableLayoutType.FIXED,
//             rows,
//             borders: {
//               top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//             },
//           })
//         );
        
//         // Add spacing after the table
//         if (block.after && block.after > 0) {
//           sectionChildren.push(new Paragraph({
//             children: [],
//             spacing: { before: 0, after: block.after }
//           }));
//         }
        
//         continue;
//       }
  
//       if (block.kind === "heading" || block.kind === "quote" || block.kind === "paragraph") {
//         const paraChildren = [];
//         if (Array.isArray(block.runs)) {
//           for (const run of block.runs) {
//             if (run.kind === "image") {
//               const img = await resolveImage(run.src);
//               if (img) {
//                 paraChildren.push(
//                   new ImageRun({ 
//                     data: img.data, 
//                     transformation: { width: run.width || img.width || 300, height: run.height || img.height || 300 }, 
//                     type: img.type 
//                   })
//                 );
//               }
//             } else if (run.kind === "break") {
//               paraChildren.push(new TextRun({ break: 1 }));
//             } else if (run.kind === "text") {
//               const baseOpts = {
//                 bold: !!run.bold,
//                 italics: !!run.italics,
//                 underline: run.underline || run.isLink ? {} : undefined,
//                 strike: !!run.strike,
//                 color: run.isLink ? "0000FF" : run.color,
//                 font: run.code ? "Courier New" : run.fontFamily,
//                 size: run.fontSize,
//                 shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
//               };
//               const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
//               const lines = (run.text || "").split("\n");
//               lines.forEach((lineText, li) => {
//                 const parts = lineText.split("\t");
//                 parts.forEach((part, pi) => {
//                   const t = normalizeSpaces(part);
//                   const tr = new TextRun({ text: t, ...baseOpts });
//                   if (run.isLink && run.url) {
//                     paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
//                   } else {
//                     paraChildren.push(tr);
//                   }
//                   if (pi < parts.length - 1) {
//                     paraChildren.push(new TextRun({ text: "\t" }));
//                   }
//                 });
//                 if (li < lines.length - 1) {
//                   paraChildren.push(new TextRun({ break: 1 }));
//                 }
//               });
//             }
//           }
//         }
  
//         let paragraph;
//         if (block.kind === "heading") {
//           const headingLevel = block.tag === "h1" ? HeadingLevel.HEADING_1 : block.tag === "h2" ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3;
//           paragraph = new Paragraph({ 
//             heading: headingLevel, 
//             alignment: mapAlign(block.align), 
//             spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
//             children: paraChildren 
//           });
//         } else if (block.kind === "quote") {
//           paragraph = new Paragraph({ 
//             alignment: mapAlign(block.align), 
//             spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
//             children: [new TextRun({ text: "“" }), ...paraChildren, new TextRun({ text: "”" })] 
//           });
//         } else {
//           paragraph = new Paragraph({ 
//             alignment: mapAlign(block.align), 
//             spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
//             children: paraChildren 
//           });
//         }
//         sectionChildren.push(paragraph);
//       }
//     }
  
//     const doc = new Document({
//       sections: [
//         {
//           properties: {
//             page: {
//               margin: {
//                 top: 720,    // 0.5 inch = 720 twips
//                 right: 720,  // 0.5 inch = 720 twips
//                 bottom: 720, // 0.5 inch = 720 twips
//                 left: 720,   // 0.5 inch = 720 twips
//               }
//             }
//           },
//           children: sectionChildren,
//         },
//       ],
//     });
  
//     const blob = await Packer.toBlob(doc);
//     saveAs(blob, "document.docx");
//   };

const handleDownloadDocx = async (editor) => {
    const editorState = editor.getEditorState();
    const blocks = [];
  
    // Capture editor-level default font family and size from DOM
    const readEditorDefaults = () => {
      const rootEl = document.querySelector('.ContentEditable__root');
      const cs = rootEl ? window.getComputedStyle(rootEl) : null;
      const fontFamily = cs?.fontFamily ? cs.fontFamily.split(',')[0].replace(/["']/g, '').trim() : undefined;
      const fontSizePx = cs?.fontSize ? parseFloat(cs.fontSize) : undefined;
      const fontSizeHalfPoints = Number.isFinite(fontSizePx) ? Math.round((fontSizePx * 0.75) * 2) : undefined; // px->pt->halfPoints
      return { fontFamily, fontSizeHalfPoints };
    };
    const editorDefaults = readEditorDefaults();
  
    // Measure table column widths directly from the DOM so DOCX matches the editor UI
    const measureTablesFromDOM = () => {
      const results = [];
      const rootEl = document.querySelector('.ContentEditable__root');
      if (!rootEl) return results;
      const tableEls = rootEl.querySelectorAll('table');
      tableEls.forEach((table) => {
        try {
          const firstRow = table.rows && table.rows[0];
          if (!firstRow) {
            results.push(null);
            return;
          }
          const colWidthsPx = [];
          for (let ci = 0; ci < firstRow.cells.length; ci++) {
            const rect = firstRow.cells[ci].getBoundingClientRect();
            colWidthsPx.push(Math.max(0, Math.round(rect.width)));
          }
          const totalPx = colWidthsPx.reduce((a, b) => a + b, 0);
          const pxToTwips = (px) => Math.max(0, Math.round(px * 15)); // 1px≈1/96in; 1in=1440 twips => 1440/96=15
          const colsTwips = colWidthsPx.map(pxToTwips);
          const totalTwips = pxToTwips(totalPx);
          results.push({ colsTwips, totalTwips });
        } catch (e) {
          results.push(null);
        }
      });
      return results;
    };
  
    const measuredTables = measureTablesFromDOM();
    let measuredTableIndex = 0;

    // Measure image dimensions directly from the DOM so DOCX matches the editor UI
    const measureImagesFromDOM = () => {
      const results = [];
      const rootEl = document.querySelector('.ContentEditable__root');
      if (!rootEl) return results;
      const imageEls = rootEl.querySelectorAll('img');
      imageEls.forEach((img) => {
        const rect = img.getBoundingClientRect();
        results.push({ width: Math.max(0, Math.round(rect.width)), height: Math.max(0, Math.round(rect.height)) });
      });
      return results;
    };

    const measuredImages = measureImagesFromDOM();
    let measuredImageIndex = 0;
  
    const parseStyleToObject = (styleString) => {
      const style = {};
      if (!styleString) return style;
      styleString.split(";").forEach((decl) => {
        const [prop, val] = decl.split(":");
        if (prop && val) {
          style[prop.trim()] = val.trim();
        }
      });
      return style;
    };
  
    const normalizeFontFamily = (family) => {
      if (!family) return undefined;
      const first = family.split(",")[0] || "";
      return first.replace(/["']/g, "").trim() || undefined;
    };
  
    const cssSizeToHalfPoints = (size) => {
      if (!size) return undefined;
      const s = String(size).trim().toLowerCase();
      if (s.endsWith("pt")) {
        const pt = parseFloat(s);
        return Number.isFinite(pt) ? Math.round(pt * 2) : undefined;
      }
      if (s.endsWith("px")) {
        const px = parseFloat(s);
        if (!Number.isFinite(px)) return undefined;
        const pt = px * 0.75; // 1pt = 1.333px => pt = px * 0.75
        return Math.round(pt * 2);
      }
      return undefined;
    };
  
    const colorToHexNoHash = (c) => {
      if (!c) return undefined;
      const m = c.trim();
      if (m.startsWith("#")) return m.slice(1).toUpperCase();
      return m.toUpperCase();
    };
  
    const cssLineHeightToDocxLine = (lineHeight, fallbackHalfPoints) => {
      if (!lineHeight) return undefined;
      const s = String(lineHeight).trim().toLowerCase();
      if (s.endsWith('%')) {
        const pct = parseFloat(s);
        if (Number.isFinite(pct)) return Math.round((pct / 100) * 240);
      }
      const num = parseFloat(s);
      if (Number.isFinite(num) && !s.endsWith('px') && !s.endsWith('pt')) {
        return Math.round(num * 240); // 1.0 -> 240
      }
      let linePt;
      if (s.endsWith('pt')) {
        linePt = parseFloat(s);
      } else if (s.endsWith('px')) {
        const px = parseFloat(s);
        linePt = Number.isFinite(px) ? px * 0.75 : undefined;
      }
      if (Number.isFinite(linePt)) {
        const fontPt = fallbackHalfPoints ? fallbackHalfPoints / 2 : 11; // default ~11pt
        const mult = linePt / fontPt;
        return Math.round(mult * 240);
      }
      return undefined;
    };
  
    editorState.read(() => {
      const root = $getRoot();
  
      const collectRunsFromNode = (node, linkMeta) => {
        const runs = [];
        const type = node.getType();
        if (type === "text") {
          const text = node.getTextContent();
          if (text && text.length > 0) {
            const styleObj = parseStyleToObject(node.getStyle && node.getStyle());
            const color = colorToHexNoHash(styleObj["color"]);
            const bgColor = colorToHexNoHash(styleObj["background-color"]);
            const fontFamily = normalizeFontFamily(styleObj["font-family"]) || editorDefaults.fontFamily;
            const fontSize = cssSizeToHalfPoints(styleObj["font-size"]) || editorDefaults.fontSizeHalfPoints;
            runs.push({
              kind: "text",
              text,
              bold: node.hasFormat("bold"),
              italics: node.hasFormat("italic"),
              underline: node.hasFormat("underline"),
              strike: node.hasFormat("strikethrough"),
              code: node.hasFormat("code"),
              color,
              bgColor,
              fontFamily,
              fontSize,
              isLink: linkMeta?.isLink || false,
              url: linkMeta?.url,
            });
          }
        } else if (type === "linebreak") {
          runs.push({ kind: "break" });
        } else if (type === "link") {
          const url = node.getURL && node.getURL();
          node.getChildren().forEach((child) => {
            runs.push(...collectRunsFromNode(child, { isLink: true, url }));
          });
        } else if (type === "image") {
          runs.push({ kind: "image", src: node.getSrc && node.getSrc(), index: measuredImageIndex++ });
        } else {
          if (node.getChildren) {
            node.getChildren().forEach((child) => {
              runs.push(...collectRunsFromNode(child, linkMeta));
            });
          }
        }
        return runs;
      };
  
      root.getChildren().forEach((node) => {
        const nodeType = node.getType();
  
        const nodeStyle = parseStyleToObject(node.getStyle && node.getStyle());
        const paraLine = cssLineHeightToDocxLine(nodeStyle["line-height"], editorDefaults.fontSizeHalfPoints);
        
        // Use consistent spacing for all elements to ensure alignment
        const beforeSpacing = 60; // Reduced from 240 to 120 for consistent spacing
        const afterSpacing = 60;  // Reduced from 240 to 120 for consistent spacing
  
        if (nodeType === "heading") {
          const tag = node.getTag && node.getTag();
          const runs = collectRunsFromNode(node);
          blocks.push({ kind: "heading", tag, runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
        } else if (nodeType === "quote") {
          const runs = collectRunsFromNode(node);
          blocks.push({ kind: "quote", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
        } else if (nodeType === "list") {
          const listTag = node.getTag && node.getTag();
          const items = node.getChildren();
          items.forEach((listItem, idx) => {
            const runs = collectRunsFromNode(listItem);
            blocks.push({
              kind: "list-item",
              ordered: listTag === "ol",
              index: idx,
              runs,
              align: node.getFormatType && node.getFormatType(),
              line: paraLine,
              before: beforeSpacing,
              after: afterSpacing,
            });
          });
        } else if (nodeType === "table") {
          const tableRows = [];
          const rowNodes = node.getChildren();
          rowNodes.forEach((rowNode) => {
            const rowCells = [];
            const cellNodes = rowNode.getChildren();
            cellNodes.forEach((cellNode) => {
              const paraNodes = cellNode.getChildren();
              const paragraphs = [];
              if (Array.isArray(paraNodes) && paraNodes.length > 0) {
                paraNodes.forEach((p) => {
                  const pStyle = parseStyleToObject(p.getStyle && p.getStyle());
                  const pLine = cssLineHeightToDocxLine(pStyle["line-height"], editorDefaults.fontSizeHalfPoints);
                  const runs = collectRunsFromNode(p);
                  paragraphs.push({ runs, align: p.getFormatType && p.getFormatType(), line: pLine });
                });
              } else {
                const runs = collectRunsFromNode(cellNode);
                paragraphs.push({ runs, align: cellNode.getFormatType && cellNode.getFormatType(), line: paraLine });
              }
              rowCells.push({ paragraphs });
            });
            tableRows.push(rowCells);
          });
          const dims = measuredTables[measuredTableIndex++] || null;
          blocks.push({ 
            kind: "table", 
            rows: tableRows, 
            dims,
            align: node.getFormatType && node.getFormatType(),
            before: beforeSpacing,
            after: afterSpacing
          });
        } else if (nodeType === "paragraph") {
          const runs = collectRunsFromNode(node);
          blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
        } else if (nodeType === "image") {
          const runs = collectRunsFromNode(node);
          blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
        } else {
          const runs = collectRunsFromNode(node);
          if (runs.length > 0) {
            blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
          }
        }
      });
    });
  
    const dataUrlToUint8Array = async (dataUrl) => {
      const res = await fetch(dataUrl);
      const blob = await res.blob();
      const ab = await blob.arrayBuffer();
      return new Uint8Array(ab);
    };
  
    const loadImageElement = (src) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = (e) => reject(e);
        img.src = src;
      });
    };
  
    const convertImageToPngBytes = async (img) => {
      try {
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth || img.width || 1;
        canvas.height = img.naturalHeight || img.height || 1;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
        if (!blob) return null;
        const ab = await blob.arrayBuffer();
        return new Uint8Array(ab);
      } catch (e) {
        console.warn("PNG conversion failed", e);
        return null;
      }
    };
  
    const sniffImageType = (bytes) => {
      if (!bytes || bytes.length < 12) return null;
      if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47 && bytes[4] === 0x0d && bytes[5] === 0x0a && bytes[6] === 0x1a && bytes[7] === 0x0a) {
        return "png";
      }
      if (bytes[0] === 0xff && bytes[1] === 0xd8) return "jpeg";
      if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38 && (bytes[4] === 0x39 || bytes[4] === 0x37) && bytes[5] === 0x61) {
        return "gif";
      }
      return null;
    };
  
    const tryBitmapToPng = async (blob) => {
      try {
        if (typeof createImageBitmap === "function") {
          const bitmap = await createImageBitmap(blob);
          const canvas = document.createElement("canvas");
          canvas.width = bitmap.width || 1;
          canvas.height = bitmap.height || 1;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(bitmap, 0, 0);
          const out = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
          if (!out) return null;
          const ab = await out.arrayBuffer();
          return new Uint8Array(ab);
        }
      } catch (e) {
        console.warn("Bitmap conversion failed", e);
      }
      return null;
    };
  
    const resolveImage = async (src) => {
      if (!src) return null;
      let data;
      let naturalWidth;
      let naturalHeight;
      let type;
  
      if (src.startsWith("data:")) {
        try {
          const img = await loadImageElement(src);
          naturalWidth = img.naturalWidth || 400;
          naturalHeight = img.naturalHeight || 300;
          const png = await convertImageToPngBytes(img);
          if (png) {
            data = png;
            type = "png";
          } else {
            data = await dataUrlToUint8Array(src);
            type = sniffImageType(data) || "png";
          }
        } catch (e) {
          console.warn("Failed to load data URL image for DOCX:", e);
          data = await dataUrlToUint8Array(src);
          type = sniffImageType(data) || "png";
          naturalWidth = 400;
          naturalHeight = 300;
        }
      } else {
        const res = await fetch(src, { mode: "cors" }).catch((e) => {
          console.warn("Image fetch failed due to CORS or network:", src, e);
          return null;
        });
        if (!res || !res.ok) return null;
        const blob = await res.blob();
        const objectUrl = URL.createObjectURL(blob);
        try {
          const img = await loadImageElement(objectUrl);
          naturalWidth = img.naturalWidth || 400;
          naturalHeight = img.naturalHeight || 300;
          const png = await convertImageToPngBytes(img);
          if (png) {
            data = png;
            type = "png";
          } else {
            const ab = await blob.arrayBuffer();
            data = new Uint8Array(ab);
            type = sniffImageType(data);
            if (!type) {
              const conv = await tryBitmapToPng(blob);
              if (conv) {
                data = conv;
                type = "png";
              }
            }
          }
        } catch (e) {
          console.warn("Failed to load remote image into canvas, falling back to raw bytes", e);
          const ab = await blob.arrayBuffer();
          data = new Uint8Array(ab);
          type = sniffImageType(data);
          if (!type) {
            const conv = await tryBitmapToPng(blob);
            if (conv) {
              data = conv;
              type = "png";
            }
          }
          naturalWidth = 400;
          naturalHeight = 300;
        } finally {
          URL.revokeObjectURL(objectUrl);
        }
      }
  
      if (!data) return null;
      return { data, naturalWidth, naturalHeight, type: type || "png" };
    };
  
    const mapAlign = (align) => {
      switch (align) {
        case "center":
          return AlignmentType.CENTER;
        case "right":
          return AlignmentType.RIGHT;
        case "justify":
          return AlignmentType.JUSTIFIED;
        default:
          return AlignmentType.LEFT;
      }
    };
  
    const sectionChildren = [];
  
    const buildParagraphFromRuns = async (runs, align, line, before, after) => {
      const paraChildren = [];
  
      const pushTextSegments = (run) => {
        const baseOpts = {
          bold: !!run.bold,
          italics: !!run.italics,
          underline: run.underline || run.isLink ? {} : undefined,
          strike: !!run.strike,
          color: run.isLink ? "0000FF" : run.color,
          font: run.code ? "Courier New" : run.fontFamily,
          size: run.fontSize,
          shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
        };
        const text = run.text || "";
        const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
        const lines = text.split("\n");
        lines.forEach((lineText, li) => {
          const parts = lineText.split("\t");
          parts.forEach((part, pi) => {
            const t = normalizeSpaces(part);
            const tr = new TextRun({ text: t, ...baseOpts });
            if (run.isLink && run.url) {
              paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
            } else {
              paraChildren.push(tr);
            }
            if (pi < parts.length - 1) {
              paraChildren.push(new TextRun({ text: "\t" }));
            }
          });
          if (li < lines.length - 1) {
            paraChildren.push(new TextRun({ break: 1 }));
          }
        });
      };
  
      if (Array.isArray(runs)) {
        for (const run of runs) {
          if (run.kind === "image") {
            const img = await resolveImage(run.src);
            if (img) {
              const measured = measuredImages[run.index];
              let widthPt = 300;
              let heightPt = 225;
              if (measured && measured.width > 0 && measured.height > 0) {
                widthPt = Math.round(measured.width * 0.75);
                heightPt = Math.round(measured.height * 0.75);
              } else {
                widthPt = Math.round((img.naturalWidth || 400) * 0.75);
                heightPt = Math.round((img.naturalHeight || 300) * 0.75);
              }
              console.log(`Image ${run.index} debug: measured ${measured?.width || 'N/A'}px x ${measured?.height || 'N/A'}px, natural ${img.naturalWidth}px x ${img.naturalHeight}px, using ${widthPt}pt x ${heightPt}pt in DOCX`);
              paraChildren.push(
                new ImageRun({ 
                  data: img.data, 
                  transformation: { width: widthPt, height: heightPt }, 
                  type: img.type 
                })
              );
            }
          } else if (run.kind === "break") {
            paraChildren.push(new TextRun({ break: 1 }));
          } else if (run.kind === "text") {
            pushTextSegments(run);
          }
        }
      }
  
      return new Paragraph({ 
        alignment: mapAlign(align), 
        spacing: { before, after, line: line || 240 }, 
        children: paraChildren 
      });
    };
  
    for (const block of blocks) {
      if (block.kind === "list-item") {
        const childrenRuns = [];
        if (block.ordered) {
          childrenRuns.push(new TextRun({ text: `${(block.index || 0) + 1}. ` }));
        } else {
          childrenRuns.push(new TextRun({ text: "• " }));
        }
        for (const run of block.runs) {
          if (run.kind === "image") {
            const img = await resolveImage(run.src);
            if (img) {
              const measured = measuredImages[run.index];
              let widthPt = 300;
              let heightPt = 225;
              if (measured && measured.width > 0 && measured.height > 0) {
                widthPt = Math.round(measured.width * 0.75);
                heightPt = Math.round(measured.height * 0.75);
              } else {
                widthPt = Math.round((img.naturalWidth || 400) * 0.75);
                heightPt = Math.round((img.naturalHeight || 300) * 0.75);
              }
              console.log(`Image ${run.index} debug: measured ${measured?.width || 'N/A'}px x ${measured?.height || 'N/A'}px, natural ${img.naturalWidth}px x ${img.naturalHeight}px, using ${widthPt}pt x ${heightPt}pt in DOCX`);
              childrenRuns.push(
                new ImageRun({ 
                  data: img.data, 
                  transformation: { width: widthPt, height: heightPt }, 
                  type: img.type 
                })
              );
            }
          } else if (run.kind === "break") {
            childrenRuns.push(new TextRun({ break: 1 }));
          } else if (run.kind === "text") {
            const baseOpts = {
              bold: !!run.bold,
              italics: !!run.italics,
              underline: run.underline ? {} : undefined,
              strike: !!run.strike,
              color: run.isLink ? "0000FF" : run.color,
              font: run.code ? "Courier New" : run.fontFamily,
              size: run.fontSize,
              shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
            };
            const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
            const lines = (run.text || "").split("\n");
            lines.forEach((lineText, li) => {
              const parts = lineText.split("\t");
              parts.forEach((part, pi) => {
                const t = normalizeSpaces(part);
                const tr = new TextRun({ text: t, ...baseOpts });
                if (run.isLink && run.url) {
                  childrenRuns.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
                } else {
                  childrenRuns.push(tr);
                }
                if (pi < parts.length - 1) {
                  childrenRuns.push(new TextRun({ text: "\t" }));
                }
              });
              if (li < lines.length - 1) {
                childrenRuns.push(new TextRun({ break: 1 }));
              }
            });
          }
        }
        sectionChildren.push(
          new Paragraph({ 
            alignment: mapAlign(block.align), 
            spacing: { before: block.before || 120, after: block.after || 120, line: block.line || 240 }, 
            children: childrenRuns 
          })
        );
        continue;
      }
  
      if (block.kind === "table") {
        const rows = [];
        const pageContentWidthTwips = 9360; // ~6.5 inches
  
        let columnWidths = [];
        let tableWidthTwips = pageContentWidthTwips;
        if (block.dims && Array.isArray(block.dims.colsTwips)) {
          const sum = block.dims.colsTwips.reduce((a, b) => a + b, 0) || 0;
          if (sum > 0) {
            const scale = sum > pageContentWidthTwips ? pageContentWidthTwips / sum : 1;
            columnWidths = block.dims.colsTwips.map((w) => Math.max(0, Math.floor(w * scale)));
            tableWidthTwips = Math.min(pageContentWidthTwips, Math.max(0, Math.floor(sum * scale)));
          }
        }
  
        if (!columnWidths.length) {
          const colsCount = (block.rows && block.rows[0] ? block.rows[0].length : 0) || 0;
          if (colsCount === 3) {
            columnWidths = [2200, 2200, pageContentWidthTwips - 2200 - 2200];
          } else if (colsCount > 0) {
            const each = Math.floor(pageContentWidthTwips / colsCount);
            columnWidths = new Array(colsCount).fill(each);
          }
        }
  
        for (const rowCells of block.rows) {
          const cells = [];
          for (let ci = 0; ci < rowCells.length; ci++) {
            const cell = rowCells[ci];
            const cellParagraphs = [];
            for (const p of cell.paragraphs) {
              cellParagraphs.push(
                await buildParagraphFromRuns(p.runs, p.align, p.line, 0, 120)
              );
            }
            cells.push(
              new TableCell({
                children: cellParagraphs,
                width: columnWidths.length ? { size: columnWidths[ci] || columnWidths[0], type: WidthType.DXA } : undefined,
                margins: { top: 100, bottom: 100, left: 120, right: 120 },
              })
            );
          }
          rows.push(new TableRow({ children: cells }));
        }
        
        // Add spacing before the table to match headings
        if (block.before && block.before > 0) {
          sectionChildren.push(new Paragraph({
            children: [],
            spacing: { before: 0, after: block.before }
          }));
        }
        
        sectionChildren.push(
          new Table({
            width: { size: tableWidthTwips, type: WidthType.DXA },
            columnWidths: columnWidths.length ? columnWidths : undefined,
            alignment: mapAlign(block.align || "left"),
            layout: TableLayoutType.FIXED,
            rows,
            borders: {
              top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
              bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
              left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
              right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
              insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
              insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
            },
          })
        );
        
        // Add spacing after the table
        if (block.after && block.after > 0) {
          sectionChildren.push(new Paragraph({
            children: [],
            spacing: { before: block.after, after: 0 }
          }));
        }
        
        continue;
      }
  
      if (block.kind === "heading" || block.kind === "quote" || block.kind === "paragraph") {
        const paraChildren = [];
        if (Array.isArray(block.runs)) {
          for (const run of block.runs) {
            if (run.kind === "image") {
              const img = await resolveImage(run.src);
			if (img) {
				const measured = measuredImages[run.index];
				let widthPt, heightPt;
			  
				if (measured && measured.width > 0 && measured.height > 0) {
				  widthPt = Math.round(measured.width * 0.75);
				  heightPt = Math.round(measured.height * 0.75);
				} else {
				  widthPt = Math.round((img.naturalWidth || 400) * 0.75);
				  heightPt = Math.round((img.naturalHeight || 300) * 0.75);
				}
			  
				// 🔍 apply a little boost (e.g. +10%)
				const BOOST = 1.1;
				widthPt = Math.round(widthPt * BOOST);
				heightPt = Math.round(heightPt * BOOST);
			  
				// 🛑 enforce max page width
				const MAX_WIDTH_PT = 700; // ~6.6in with margins
				if (widthPt > MAX_WIDTH_PT) {
				  const scale = MAX_WIDTH_PT / widthPt;
				  widthPt = MAX_WIDTH_PT;
				  heightPt = Math.round(heightPt * scale);
				  console.log(
					`Image ${run.index}: scaled to fit page (with boost) → ${widthPt}pt x ${heightPt}pt`
				  );
				}
			  
				console.log(
				  `Image ${run.index} debug: measured ${measured?.width || "N/A"}px x ${
					measured?.height || "N/A"
				  }px, natural ${img.naturalWidth}px x ${img.naturalHeight}px, using ${widthPt}pt x ${heightPt}pt in DOCX`
				);
			  
				paraChildren.push(
				  new ImageRun({
					data: img.data,
					transformation: { width: widthPt, height: heightPt },
					type: img.type,
				  })
				);
			  }
			  
            } else if (run.kind === "break") {
              paraChildren.push(new TextRun({ break: 1 }));
            } else if (run.kind === "text") {
              const baseOpts = {
                bold: !!run.bold,
                italics: !!run.italics,
                underline: run.underline || run.isLink ? {} : undefined,
                strike: !!run.strike,
                color: run.isLink ? "0000FF" : run.color,
                font: run.code ? "Courier New" : run.fontFamily,
                size: run.fontSize,
                shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
              };
              const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
              const lines = (run.text || "").split("\n");
              lines.forEach((lineText, li) => {
                const parts = lineText.split("\t");
                parts.forEach((part, pi) => {
                  const t = normalizeSpaces(part);
                  const tr = new TextRun({ text: t, ...baseOpts });
                  if (run.isLink && run.url) {
                    paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
                  } else {
                    paraChildren.push(tr);
                  }
                  if (pi < parts.length - 1) {
                    paraChildren.push(new TextRun({ text: "\t" }));
                  }
                });
                if (li < lines.length - 1) {
                  paraChildren.push(new TextRun({ break: 1 }));
                }
              });
            }
          }
        }
  
        let paragraph;
        if (block.kind === "heading") {
          const headingLevel = block.tag === "h1" ? HeadingLevel.HEADING_1 : block.tag === "h2" ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3;
          paragraph = new Paragraph({ 
            heading: headingLevel, 
            alignment: mapAlign(block.align), 
            spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
            children: paraChildren 
          });
        } else if (block.kind === "quote") {
          paragraph = new Paragraph({ 
            alignment: mapAlign(block.align), 
            spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
            children: [new TextRun({ text: "“" }), ...paraChildren, new TextRun({ text: "”" })] 
          });
        } else {
          paragraph = new Paragraph({ 
            alignment: mapAlign(block.align), 
            spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
            children: paraChildren 
          });
        }
        sectionChildren.push(paragraph);
      }
    }
  
    const doc = new Document({
      sections: [
        {
          properties: {
            page: {
              margin: {
                top: 720,    // 0.5 inch = 720 twips
                right: 720,  // 0.5 inch = 720 twips
                bottom: 720, // 0.5 inch = 720 twips
                left: 720,   // 0.5 inch = 720 twips
              }
            }
          },
          children: sectionChildren,
        },
      ],
    });
  
    const blob = await Packer.toBlob(doc);
    saveAs(blob, "document.docx");
  };

// const handleDownloadDocx = async (editor) => {
//     const editorState = editor.getEditorState();
//     const blocks = [];

//     // Capture editor-level default font family and size from DOM
//     const readEditorDefaults = () => {
//       const rootEl = document.querySelector('.ContentEditable__root');
//       const cs = rootEl ? window.getComputedStyle(rootEl) : null;
//       const fontFamily = cs?.fontFamily ? cs.fontFamily.split(',')[0].replace(/["']/g, '').trim() : undefined;
//       const fontSizePx = cs?.fontSize ? parseFloat(cs.fontSize) : undefined;
//       const fontSizeHalfPoints = Number.isFinite(fontSizePx) ? Math.round((fontSizePx * 0.75) * 2) : undefined; // px->pt->halfPoints
//       return { fontFamily, fontSizeHalfPoints };
//     };
//     const editorDefaults = readEditorDefaults();

//     // Measure table column widths directly from the DOM so DOCX matches the editor UI
//     const measureTablesFromDOM = () => {
//       const results = [];
//       const rootEl = document.querySelector('.ContentEditable__root');
//       if (!rootEl) return results;
//       const tableEls = rootEl.querySelectorAll('table');
//       tableEls.forEach((table) => {
//         try {
//           const firstRow = table.rows && table.rows[0];
//           if (!firstRow) {
//             results.push(null);
//             return;
//           }
//           const colWidthsPx = [];
//           for (let ci = 0; ci < firstRow.cells.length; ci++) {
//             const rect = firstRow.cells[ci].getBoundingClientRect();
//             colWidthsPx.push(Math.max(0, Math.round(rect.width)));
//           }
//           const totalPx = colWidthsPx.reduce((a, b) => a + b, 0);
//           const pxToTwips = (px) => Math.max(0, Math.round(px * 15)); // 1px≈1/96in; 1in=1440 twips => 1440/96=15
//           const colsTwips = colWidthsPx.map(pxToTwips);
//           const totalTwips = pxToTwips(totalPx);
//           results.push({ colsTwips, totalTwips });
//         } catch (e) {
//           results.push(null);
//         }
//       });
//       return results;
//     };

//     const measuredTables = measureTablesFromDOM();
//     let measuredTableIndex = 0;

//     // Measure image dimensions directly from the DOM so DOCX matches the editor UI

// 	const measureImagesFromDOM = async () => {
// 		const results = [];
// 		const rootEl = document.querySelector('.ContentEditable__root');
	  
// 		if (!rootEl) {
// 		  console.warn('ContentEditable__root not found in DOM. Ensure the selector matches your editor container.');
// 		  return results;
// 		}
	  
// 		const imageEls = rootEl.querySelectorAll('img');
// 		if (imageEls.length === 0) {
// 		  console.warn('No images found in .ContentEditable__root. Verify images exist in the editor.');
// 		  return results;
// 		}
	  
// 		const waitForImageLoad = (img) => {
// 		  return new Promise((resolve) => {
// 			if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
// 			  resolve();
// 			} else {
// 			  img.addEventListener('load', () => resolve(), { once: true });
// 			  img.addEventListener('error', () => {
// 				console.warn(`Failed to load image: ${img.src}`);
// 				resolve(); // Resolve to avoid hanging
// 			  }, { once: true });
// 			}
// 		  });
// 		};
	  
// 		console.log(`Found ${imageEls.length} images in .ContentEditable__root`);
	  
// 		for (const [index, img] of Array.from(imageEls).entries()) {
// 		  try {
// 			await waitForImageLoad(img);
	  
// 			// Ensure image is visible for accurate measurements
// 			const originalDisplay = img.style.display;
// 			const originalVisibility = img.style.visibility;
// 			if (img.style.display === 'none' || img.style.visibility === 'hidden') {
// 			  img.style.display = 'block';
// 			  img.style.visibility = 'visible';
// 			}
	  
// 			const rect = img.getBoundingClientRect();
// 			const width = Math.max(0, Math.round(rect.width));
// 			const height = Math.max(0, Math.round(rect.height));
	  
// 			// Restore original styles
// 			img.style.display = originalDisplay;
// 			img.style.visibility = originalVisibility;
	  
// 			console.log(`Image ${index}: src=${img.src}, complete=${img.complete}, DOM dimensions=${width}px x ${height}px, natural=${img.naturalWidth}px x ${img.naturalHeight}px`);
	  
// 			if (width > 0 && height > 0) {
// 			  results.push({ width, height });
// 			} else {
// 			  console.warn(`Skipping image ${index} (${img.src}): Invalid DOM dimensions (width: ${width}, height: ${height})`);
// 			}
// 		  } catch (e) {
// 			console.error(`Error processing image ${index} (${img.src}):`, e);
// 		  }
// 		}
	  
// 		console.log(`Measured ${results.length} images with valid DOM dimensions`);
// 		return results;
// 	  };
//     const measuredImages = measureImagesFromDOM();
//     let measuredImageIndex = 0;

//     const parseStyleToObject = (styleString) => {
//       const style = {};
//       if (!styleString) return style;
//       styleString.split(";").forEach((decl) => {
//         const [prop, val] = decl.split(":");
//         if (prop && val) {
//           style[prop.trim()] = val.trim();
//         }
//       });
//       return style;
//     };

//     const normalizeFontFamily = (family) => {
//       if (!family) return undefined;
//       const first = family.split(",")[0] || "";
//       return first.replace(/["']/g, "").trim() || undefined;
//     };

//     const cssSizeToHalfPoints = (size) => {
//       if (!size) return undefined;
//       const s = String(size).trim().toLowerCase();
//       if (s.endsWith("pt")) {
//         const pt = parseFloat(s);
//         return Number.isFinite(pt) ? Math.round(pt * 2) : undefined;
//       }
//       if (s.endsWith("px")) {
//         const px = parseFloat(s);
//         if (!Number.isFinite(px)) return undefined;
//         const pt = px * 0.75; // 1pt = 1.333px => pt = px * 0.75
//         return Math.round(pt * 2);
//       }
//       return undefined;
//     };

//     const colorToHexNoHash = (c) => {
//       if (!c) return undefined;
//       const m = c.trim();
//       if (m.startsWith("#")) return m.slice(1).toUpperCase();
//       return m.toUpperCase();
//     };

//     const cssLineHeightToDocxLine = (lineHeight, fallbackHalfPoints) => {
//       if (!lineHeight) return undefined;
//       const s = String(lineHeight).trim().toLowerCase();
//       if (s.endsWith('%')) {
//         const pct = parseFloat(s);
//         if (Number.isFinite(pct)) return Math.round((pct / 100) * 240);
//       }
//       const num = parseFloat(s);
//       if (Number.isFinite(num) && !s.endsWith('px') && !s.endsWith('pt')) {
//         return Math.round(num * 240); // 1.0 -> 240
//       }
//       let linePt;
//       if (s.endsWith('pt')) {
//         linePt = parseFloat(s);
//       } else if (s.endsWith('px')) {
//         const px = parseFloat(s);
//         linePt = Number.isFinite(px) ? px * 0.75 : undefined;
//       }
//       if (Number.isFinite(linePt)) {
//         const fontPt = fallbackHalfPoints ? fallbackHalfPoints / 2 : 11; // default ~11pt
//         const mult = linePt / fontPt;
//         return Math.round(mult * 240);
//       }
//       return undefined;
//     };

//     editorState.read(() => {
//       const root = $getRoot();

//       const collectRunsFromNode = (node, linkMeta) => {
//         const runs = [];
//         const type = node.getType();
//         if (type === "text") {
//           const text = node.getTextContent();
//           if (text && text.length > 0) {
//             const styleObj = parseStyleToObject(node.getStyle && node.getStyle());
//             const color = colorToHexNoHash(styleObj["color"]);
//             const bgColor = colorToHexNoHash(styleObj["background-color"]);
//             const fontFamily = normalizeFontFamily(styleObj["font-family"]) || editorDefaults.fontFamily;
//             const fontSize = cssSizeToHalfPoints(styleObj["font-size"]) || editorDefaults.fontSizeHalfPoints;
//             runs.push({
//               kind: "text",
//               text,
//               bold: node.hasFormat("bold"),
//               italics: node.hasFormat("italic"),
//               underline: node.hasFormat("underline"),
//               strike: node.hasFormat("strikethrough"),
//               code: node.hasFormat("code"),
//               color,
//               bgColor,
//               fontFamily,
//               fontSize,
//               isLink: linkMeta?.isLink || false,
//               url: linkMeta?.url,
//             });
//           }
//         } else if (type === "linebreak") {
//           runs.push({ kind: "break" });
//         } else if (type === "link") {
//           const url = node.getURL && node.getURL();
//           node.getChildren().forEach((child) => {
//             runs.push(...collectRunsFromNode(child, { isLink: true, url }));
//           });
//         } else if (type === "image") {
//           runs.push({ kind: "image", src: node.getSrc && node.getSrc(), index: measuredImageIndex++ });
//         } else {
//           if (node.getChildren) {
//             node.getChildren().forEach((child) => {
//               runs.push(...collectRunsFromNode(child, linkMeta));
//             });
//           }
//         }
//         return runs;
//       };

//       root.getChildren().forEach((node) => {
//         const nodeType = node.getType();

//         const nodeStyle = parseStyleToObject(node.getStyle && node.getStyle());
//         const paraLine = cssLineHeightToDocxLine(nodeStyle["line-height"], editorDefaults.fontSizeHalfPoints);

//         // Use consistent spacing for all elements to ensure alignment
//         const beforeSpacing = 60; // Reduced from 240 to 60 for consistent spacing
//         const afterSpacing = 60;  // Reduced from 240 to 60 for consistent spacing

//         if (nodeType === "heading") {
//           const tag = node.getTag && node.getTag();
//           const runs = collectRunsFromNode(node);
//           blocks.push({ kind: "heading", tag, runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//         } else if (nodeType === "quote") {
//           const runs = collectRunsFromNode(node);
//           blocks.push({ kind: "quote", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//         } else if (nodeType === "list") {
//           const listTag = node.getTag && node.getTag();
//           const items = node.getChildren();
//           items.forEach((listItem, idx) => {
//             const runs = collectRunsFromNode(listItem);
//             blocks.push({
//               kind: "list-item",
//               ordered: listTag === "ol",
//               index: idx,
//               runs,
//               align: node.getFormatType && node.getFormatType(),
//               line: paraLine,
//               before: beforeSpacing,
//               after: afterSpacing,
//             });
//           });
//         } else if (nodeType === "table") {
//           const tableRows = [];
//           const rowNodes = node.getChildren();
//           rowNodes.forEach((rowNode) => {
//             const rowCells = [];
//             const cellNodes = rowNode.getChildren();
//             cellNodes.forEach((cellNode) => {
//               const paraNodes = cellNode.getChildren();
//               const paragraphs = [];
//               if (Array.isArray(paraNodes) && paraNodes.length > 0) {
//                 paraNodes.forEach((p) => {
//                   const pStyle = parseStyleToObject(p.getStyle && p.getStyle());
//                   const pLine = cssLineHeightToDocxLine(pStyle["line-height"], editorDefaults.fontSizeHalfPoints);
//                   const runs = collectRunsFromNode(p);
//                   paragraphs.push({ runs, align: p.getFormatType && p.getFormatType(), line: pLine });
//                 });
//               } else {
//                 const runs = collectRunsFromNode(cellNode);
//                 paragraphs.push({ runs, align: cellNode.getFormatType && cellNode.getFormatType(), line: paraLine });
//               }
//               rowCells.push({ paragraphs });
//             });
//             tableRows.push(rowCells);
//           });
//           const dims = measuredTables[measuredTableIndex++] || null;
//           blocks.push({ 
//             kind: "table", 
//             rows: tableRows, 
//             dims,
//             align: node.getFormatType && node.getFormatType(),
//             before: beforeSpacing,
//             after: afterSpacing
//           });
//         } else if (nodeType === "paragraph") {
//           const runs = collectRunsFromNode(node);
//           blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//         } else if (nodeType === "image") {
//           const runs = collectRunsFromNode(node);
//           blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//         } else {
//           const runs = collectRunsFromNode(node);
//           if (runs.length > 0) {
//             blocks.push({ kind: "paragraph", runs, align: node.getFormatType && node.getFormatType(), line: paraLine, before: beforeSpacing, after: afterSpacing });
//           }
//         }
//       });
//     });

//     const dataUrlToUint8Array = async (dataUrl) => {
//       const res = await fetch(dataUrl);
//       const blob = await res.blob();
//       const ab = await blob.arrayBuffer();
//       return new Uint8Array(ab);
//     };

//     const loadImageElement = (src) => {
//       return new Promise((resolve, reject) => {
//         const img = new Image();
//         img.onload = () => resolve(img);
//         img.onerror = (e) => reject(e);
//         img.src = src;
//       });
//     };

//     const convertImageToPngBytes = async (img) => {
//       try {
//         const canvas = document.createElement("canvas");
//         canvas.width = img.naturalWidth || img.width || 1;
//         canvas.height = img.naturalHeight || img.height || 1;
//         const ctx = canvas.getContext("2d");
//         ctx.drawImage(img, 0, 0);
//         const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
//         if (!blob) return null;
//         const ab = await blob.arrayBuffer();
//         return new Uint8Array(ab);
//       } catch (e) {
//         console.warn("PNG conversion failed", e);
//         return null;
//       }
//     };

//     const sniffImageType = (bytes) => {
//       if (!bytes || bytes.length < 12) return null;
//       if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47 && bytes[4] === 0x0d && bytes[5] === 0x0a && bytes[6] === 0x1a && bytes[7] === 0x0a) {
//         return "png";
//       }
//       if (bytes[0] === 0xff && bytes[1] === 0xd8) return "jpeg";
//       if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38 && (bytes[4] === 0x39 || bytes[4] === 0x37) && bytes[5] === 0x61) {
//         return "gif";
//       }
//       return null;
//     };

//     const tryBitmapToPng = async (blob) => {
//       try {
//         if (typeof createImageBitmap === "function") {
//           const bitmap = await createImageBitmap(blob);
//           const canvas = document.createElement("canvas");
//           canvas.width = bitmap.width || 1;
//           canvas.height = bitmap.height || 1;
//           const ctx = canvas.getContext("2d");
//           ctx.drawImage(bitmap, 0, 0);
//           const out = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
//           if (!out) return null;
//           const ab = await out.arrayBuffer();
//           return new Uint8Array(ab);
//         }
//       } catch (e) {
//         console.warn("Bitmap conversion failed", e);
//       }
//       return null;
//     };

//     const resolveImage = async (src) => {
//       if (!src) return null;
//       let data;
//       let naturalWidth;
//       let naturalHeight;
//       let type;

//       if (src.startsWith("data:")) {
//         try {
//           const img = await loadImageElement(src);
//           naturalWidth = img.naturalWidth || 400;
//           naturalHeight = img.naturalHeight || 300;
//           const png = await convertImageToPngBytes(img);
//           if (png) {
//             data = png;
//             type = "png";
//           } else {
//             data = await dataUrlToUint8Array(src);
//             type = sniffImageType(data) || "png";
//           }
//         } catch (e) {
//           console.warn("Failed to load data URL image for DOCX:", e);
//           data = await dataUrlToUint8Array(src);
//           type = sniffImageType(data) || "png";
//           naturalWidth = 400;
//           naturalHeight = 300;
//         }
//       } else {
//         const res = await fetch(src, { mode: "cors" }).catch((e) => {
//           console.warn("Image fetch failed due to CORS or network:", src, e);
//           return null;
//         });
//         if (!res || !res.ok) return null;
//         const blob = await res.blob();
//         const objectUrl = URL.createObjectURL(blob);
//         try {
//           const img = await loadImageElement(objectUrl);
//           naturalWidth = img.naturalWidth || 400;
//           naturalHeight = img.naturalHeight || 300;
//           const png = await convertImageToPngBytes(img);
//           if (png) {
//             data = png;
//             type = "png";
//           } else {
//             const ab = await blob.arrayBuffer();
//             data = new Uint8Array(ab);
//             type = sniffImageType(data);
//             if (!type) {
//               const conv = await tryBitmapToPng(blob);
//               if (conv) {
//                 data = conv;
//                 type = "png";
//               }
//             }
//           }
//         } catch (e) {
//           console.warn("Failed to load remote image into canvas, falling back to raw bytes", e);
//           const ab = await blob.arrayBuffer();
//           data = new Uint8Array(ab);
//           type = sniffImageType(data);
//           if (!type) {
//             const conv = await tryBitmapToPng(blob);
//             if (conv) {
//               data = conv;
//               type = "png";
//             }
//           }
//           naturalWidth = 400;
//           naturalHeight = 300;
//         } finally {
//           URL.revokeObjectURL(objectUrl);
//         }
//       }

//       if (!data) return null;
//       return { data, naturalWidth, naturalHeight, type: type || "png" };
//     };

//     const mapAlign = (align) => {
//       switch (align) {
//         case "center":
//           return AlignmentType.CENTER;
//         case "right":
//           return AlignmentType.RIGHT;
//         case "justify":
//           return AlignmentType.JUSTIFIED;
//         default:
//           return AlignmentType.LEFT;
//       }
//     };

//     const constrainImageDimensions = (widthPx, heightPx) => {
//       const maxWidthPt = 432; // 6 inches * 72 pt/inch
//       const widthPt = Math.round(widthPx * 0.75); // Convert px to pt
//       if (widthPt <= maxWidthPt) {
//         return { widthPt, heightPt: Math.round(heightPx * 0.75) };
//       }
//       const aspectRatio = widthPx / heightPx;
//       const heightPt = Math.round(maxWidthPt / aspectRatio);
//       return { widthPt: maxWidthPt, heightPt };
//     };

// 	const buildParagraphFromRuns = async (runs, align, line, before, after) => {
// 		const paraChildren = [];
	  
// 		const pushTextSegments = (run) => {
// 		  const baseOpts = {
// 			bold: !!run.bold,
// 			italics: !!run.italics,
// 			underline: run.underline || run.isLink ? {} : undefined,
// 			strike: !!run.strike,
// 			color: run.isLink ? "0000FF" : run.color,
// 			font: run.code ? "Courier New" : run.fontFamily,
// 			size: run.fontSize,
// 			shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
// 		  };
// 		  const text = run.text || "";
// 		  const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
// 		  const lines = text.split("\n");
// 		  lines.forEach((lineText, li) => {
// 			const parts = lineText.split("\t");
// 			parts.forEach((part, pi) => {
// 			  const t = normalizeSpaces(part);
// 			  const tr = new TextRun({ text: t, ...baseOpts });
// 			  if (run.isLink && run.url) {
// 				paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
// 			  } else {
// 				paraChildren.push(tr);
// 			  }
// 			  if (pi < parts.length - 1) {
// 				paraChildren.push(new TextRun({ text: "\t" }));
// 			  }
// 			});
// 			if (li < lines.length - 1) {
// 			  paraChildren.push(new TextRun({ break: 1 }));
// 			}
// 		  });
// 		};
	  
// 		if (Array.isArray(runs)) {
// 		  for (const run of runs) {
// 			// if (run.kind === "image") {
// 			//   const img = await resolveImage(run.src);
// 			//   const measured = measuredImages[run.index];
// 			//   if (img && measured && measured.width > 0 && measured.height > 0) {
// 			// 	const { widthPt, heightPt } = constrainImageDimensions(measured.width, measured.height);
// 			// 	console.log(`Image ${run.index} debug: using DOM-measured ${measured.width}px x ${measured.height}px, converted to ${widthPt}pt x ${heightPt}pt in DOCX`);
// 			// 	paraChildren.push(
// 			// 	  new ImageRun({ 
// 			// 		data: img.data, 
// 			// 		transformation: { width: widthPt, height: heightPt }, 
// 			// 		type: img.type 
// 			// 	  })
// 			// 	);
// 			//   } else {
// 			// 	console.warn(`Skipping image ${run.index} (src: ${run.src}): Invalid or missing DOM measurements (width: ${measured?.width || 'N/A'}, height: ${measured?.height || 'N/A'})`);
// 			//   }
// 			// } 
// 			if (run.kind === "image") {
// 				const img = await resolveImage(run.src);
// 				const measured = measuredImages[run.index];
// 				let widthPx = measured && measured.width > 0 ? measured.width : (img.naturalWidth || 400);
// 				let heightPx = measured && measured.height > 0 ? measured.height : (img.naturalHeight || 300);
// 				const { widthPt, heightPt } = constrainImageDimensions(widthPx, heightPx);
// 				console.log(`Image ${run.index} debug: measured ${measured?.width || 'N/A'}px x ${measured?.height || 'N/A'}px, natural ${img.naturalWidth}px x ${img.naturalHeight}px, using ${widthPt}pt x ${heightPt}pt in DOCX`);
// 				paraChildren.push(
// 				  new ImageRun({ 
// 					data: img.data, 
// 					transformation: { width: widthPt, height: heightPt }, 
// 					type: img.type 
// 				  })
// 				);
// 			  }else if (run.kind === "break") {
// 			  paraChildren.push(new TextRun({ break: 1 }));
// 			} else if (run.kind === "text") {
// 			  pushTextSegments(run);
// 			}
// 		  }
// 		}
	  
// 		return new Paragraph({ 
// 		  alignment: mapAlign(align), 
// 		  spacing: { before, after, line: line || 240 }, 
// 		  children: paraChildren 
// 		});
// 	  };
//     const sectionChildren = [];

//     for (const block of blocks) {
//       if (block.kind === "list-item") {
//         const childrenRuns = [];
//         if (block.ordered) {
//           childrenRuns.push(new TextRun({ text: `${(block.index || 0) + 1}. ` }));
//         } else {
//           childrenRuns.push(new TextRun({ text: "• " }));
//         }
//         for (const run of block.runs) {
//           if (run.kind === "image") {
//             const img = await resolveImage(run.src);
//             if (img) {
//               const measured = measuredImages[run.index];
//               let widthPx = measured && measured.width > 0 ? measured.width : (img.naturalWidth || 400);
//               let heightPx = measured && measured.height > 0 ? measured.height : (img.naturalHeight || 300);
//               const { widthPt, heightPt } = constrainImageDimensions(widthPx, heightPx);
//               console.log(`Image ${run.index} debug: measured ${measured?.width || 'N/A'}px x ${measured?.height || 'N/A'}px, natural ${img.naturalWidth}px x ${img.naturalHeight}px, using ${widthPt}pt x ${heightPt}pt in DOCX`);
//               childrenRuns.push(
//                 new ImageRun({ 
//                   data: img.data, 
//                   transformation: { width: widthPt, height: heightPt }, 
//                   type: img.type 
//                 })
//               );
//             }
//           } else if (run.kind === "break") {
//             childrenRuns.push(new TextRun({ break: 1 }));
//           } else if (run.kind === "text") {
//             const baseOpts = {
//               bold: !!run.bold,
//               italics: !!run.italics,
//               underline: run.underline ? {} : undefined,
//               strike: !!run.strike,
//               color: run.isLink ? "0000FF" : run.color,
//               font: run.code ? "Courier New" : run.fontFamily,
//               size: run.fontSize,
//               shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
//             };
//             const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
//             const lines = (run.text || "").split("\n");
//             lines.forEach((lineText, li) => {
//               const parts = lineText.split("\t");
//               parts.forEach((part, pi) => {
//                 const t = normalizeSpaces(part);
//                 const tr = new TextRun({ text: t, ...baseOpts });
//                 if (run.isLink && run.url) {
//                   childrenRuns.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
//                 } else {
//                   childrenRuns.push(tr);
//                 }
//                 if (pi < parts.length - 1) {
//                   childrenRuns.push(new TextRun({ text: "\t" }));
//                 }
//               });
//               if (li < lines.length - 1) {
//                 childrenRuns.push(new TextRun({ break: 1 }));
//               }
//             });
//           }
//         }
//         sectionChildren.push(
//           new Paragraph({ 
//             alignment: mapAlign(block.align), 
//             spacing: { before: block.before || 60, after: block.after || 60, line: block.line || 240 }, 
//             children: childrenRuns 
//           })
//         );
//         continue;
//       }

//       if (block.kind === "table") {
//         const rows = [];
//         const pageContentWidthTwips = 9360; // ~6.5 inches

//         let columnWidths = [];
//         let tableWidthTwips = pageContentWidthTwips;
//         if (block.dims && Array.isArray(block.dims.colsTwips)) {
//           const sum = block.dims.colsTwips.reduce((a, b) => a + b, 0) || 0;
//           if (sum > 0) {
//             const scale = sum > pageContentWidthTwips ? pageContentWidthTwips / sum : 1;
//             columnWidths = block.dims.colsTwips.map((w) => Math.max(0, Math.floor(w * scale)));
//             tableWidthTwips = Math.min(pageContentWidthTwips, Math.max(0, Math.floor(sum * scale)));
//           }
//         }

//         if (!columnWidths.length) {
//           const colsCount = (block.rows && block.rows[0] ? block.rows[0].length : 0) || 0;
//           if (colsCount === 3) {
//             columnWidths = [2200, 2200, pageContentWidthTwips - 2200 - 2200];
//           } else if (colsCount > 0) {
//             const each = Math.floor(pageContentWidthTwips / colsCount);
//             columnWidths = new Array(colsCount).fill(each);
//           }
//         }

//         for (const rowCells of block.rows) {
//           const cells = [];
//           for (let ci = 0; ci < rowCells.length; ci++) {
//             const cell = rowCells[ci];
//             const cellParagraphs = [];
//             for (const p of cell.paragraphs) {
//               cellParagraphs.push(
//                 await buildParagraphFromRuns(p.runs, p.align, p.line, 0, 120)
//               );
//             }
//             cells.push(
//               new TableCell({
//                 children: cellParagraphs,
//                 width: columnWidths.length ? { size: columnWidths[ci] || columnWidths[0], type: WidthType.DXA } : undefined,
//                 margins: { top: 100, bottom: 100, left: 120, right: 120 },
//               })
//             );
//           }
//           rows.push(new TableRow({ children: cells }));
//         }

//         if (block.before && block.before > 0) {
//           sectionChildren.push(new Paragraph({
//             children: [],
//             spacing: { before: 0, after: block.before }
//           }));
//         }

//         sectionChildren.push(
//           new Table({
//             width: { size: tableWidthTwips, type: WidthType.DXA },
//             columnWidths: columnWidths.length ? columnWidths : undefined,
//             alignment: mapAlign(block.align || "left"),
//             layout: TableLayoutType.FIXED,
//             rows,
//             borders: {
//               top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//               insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
//             },
//           })
//         );

//         if (block.after && block.after > 0) {
//           sectionChildren.push(new Paragraph({
//             children: [],
//             spacing: { before: block.after, after: 0 }
//           }));
//         }

//         continue;
//       }

//       if (block.kind === "heading" || block.kind === "quote" || block.kind === "paragraph") {
//         const paraChildren = [];
//         if (Array.isArray(block.runs)) {
//           for (const run of block.runs) {
//             if (run.kind === "image") {
//               const img = await resolveImage(run.src);
//               if (img) {
//                 const measured = measuredImages[run.index];
//                 let widthPx = measured && measured.width > 0 ? measured.width : (img.naturalWidth || 400);
//                 let heightPx = measured && measured.height > 0 ? measured.height : (img.naturalHeight || 300);
//                 const { widthPt, heightPt } = constrainImageDimensions(widthPx, heightPx);
//                 console.log(`Image ${run.index} debug: measured ${measured?.width || 'N/A'}px x ${measured?.height || 'N/A'}px, natural ${img.naturalWidth}px x ${img.naturalHeight}px, using ${widthPt}pt x ${heightPt}pt in DOCX`);
//                 paraChildren.push(
//                   new ImageRun({ 
//                     data: img.data, 
//                     transformation: { width: widthPt, height: heightPt }, 
//                     type: img.type 
//                   })
//                 );
//               }
//             } else if (run.kind === "break") {
//               paraChildren.push(new TextRun({ break: 1 }));
//             } else if (run.kind === "text") {
//               const baseOpts = {
//                 bold: !!run.bold,
//                 italics: !!run.italics,
//                 underline: run.underline || run.isLink ? {} : undefined,
//                 strike: !!run.strike,
//                 color: run.isLink ? "0000FF" : run.color,
//                 font: run.code ? "Courier New" : run.fontFamily,
//                 size: run.fontSize,
//                 shading: run.bgColor ? { type: ShadingType.CLEAR, color: "auto", fill: run.bgColor } : undefined,
//               };
//               const normalizeSpaces = (s) => s.replace(/ {2,}/g, (m) => " " + "\u00A0".repeat(m.length - 1));
//               const lines = (run.text || "").split("\n");
//               lines.forEach((lineText, li) => {
//                 const parts = lineText.split("\t");
//                 parts.forEach((part, pi) => {
//                   const t = normalizeSpaces(part);
//                   const tr = new TextRun({ text: t, ...baseOpts });
//                   if (run.isLink && run.url) {
//                     paraChildren.push(new ExternalHyperlink({ link: run.url, children: [tr] }));
//                   } else {
//                     paraChildren.push(tr);
//                   }
//                   if (pi < parts.length - 1) {
//                     paraChildren.push(new TextRun({ text: "\t" }));
//                   }
//                 });
//                 if (li < lines.length - 1) {
//                   paraChildren.push(new TextRun({ break: 1 }));
//                 }
//               });
//             }
//           }
//         }

//         let paragraph;
//         if (block.kind === "heading") {
//           const headingLevel = block.tag === "h1" ? HeadingLevel.HEADING_1 : block.tag === "h2" ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3;
//           paragraph = new Paragraph({ 
//             heading: headingLevel, 
//             alignment: mapAlign(block.align), 
//             spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
//             children: paraChildren 
//           });
//         } else if (block.kind === "quote") {
//           paragraph = new Paragraph({ 
//             alignment: mapAlign(block.align), 
//             spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
//             children: [new TextRun({ text: "“" }), ...paraChildren, new TextRun({ text: "”" })] 
//           });
//         } else {
//           paragraph = new Paragraph({ 
//             alignment: mapAlign(block.align), 
//             spacing: { before: block.before, after: block.after, line: block.line || 240 }, 
//             children: paraChildren 
//           });
//         }
//         sectionChildren.push(paragraph);
//       }
//     }

//     const doc = new Document({
//       sections: [
//         {
//           properties: {
//             page: {
//               margin: {
//                 top: 720,    // 0.5 inch = 720 twips
//                 right: 720,  // 0.5 inch = 720 twips
//                 bottom: 720, // 0.5 inch = 720 twips
//                 left: 720,   // 0.5 inch = 720 twips
//               }
//             }
//           },
//           children: sectionChildren,
//         },
//       ],
//     });

//     const blob = await Packer.toBlob(doc);
//     saveAs(blob, "document.docx");
// };
	// Enhanced onChange to log editor state content
	
	function onChange(editorState) {
		editorState.read(() => {
			const root = $getRoot();
			console.log("Editor State Content:");
			root.getChildren().forEach((node, index) => {
				console.log(`Node ${index + 1}: Type=${node.getType()}`);
				if (node.getType() === "paragraph") {
					console.log("  Paragraph content:");
					node.getChildren().forEach((child, childIndex) => {
						console.log(`    Child ${childIndex + 1}: Type=${child.getType()}`);
						if (child.getType() === "text") {
							console.log(`      Text: ${child.getTextContent()}`);
							console.log(`      Formats: Bold=${child.hasFormat("bold")}, Italic=${child.hasFormat("italic")}, Underline=${child.hasFormat("underline")}`);
						} else if (child.getType() === "link") {
							console.log(`      Link Text: ${child.getTextContent()}, URL: ${child.getURL()}`);
						} else if (child.getType() === "image") {
							console.log(`      Image: src=${child.getSrc && child.getSrc()}`);
						}
					});
				} else if (node.getType() === "list") {
					console.log("  List content:");
					node.getChildren().forEach((listItem, itemIndex) => {
						console.log(`    Item ${itemIndex + 1}: ${listItem.getTextContent()}`);
					});
				} else if (node.getType() === "image") {
					console.log(`  Image: src=${node.getSrc && node.getSrc()}`);
				}
			});
		});
	}

	// function ColorToolbar() {
	// 	const [editor] = useLexicalComposerContext();
	// 	const [fontColor, setFontColor] = useState("#000000");
	// 	const [bgColor, setBgColor] = useState("#ffffff");
 
	// 	// Apply color styles to current selection
	// 	const applyStyle = (style) => {
	// 		editor.update(() => {
	// 			$patchStyleText(style);
	// 		});
	// 	};
 
	// 	// Listen to selection changes and update toolbar
	// 	const updateToolbar = () => {
	// 		editor.getEditorState().read(() => {
	// 			const selection = $getSelection();
	// 			if ($isRangeSelection(selection)) {
	// 				const styles = $getSelection(); // Get inline styles
	// 				console.log(styles, 'styles');
	// 				setFontColor(styles.color || "#000000");
	// 				setBgColor(styles["background-color"] || "#ffffff");
	// 			}
	// 		});
	// 	};
 
	// 	return (
	// 		<>
	// 			{/* Sync toolbar with editor selection */}
	// 			<OnChangePlugin
	// 				onChange={() => {
	// 					updateToolbar();
	// 				}}
	// 			/>
 
	// 			<div className="flex space-x-4 p-2 border-b bg-gray-50">
	// 				{/* Font Color Picker */}
	// 				<label className="flex items-center space-x-1">
	// 					<span>Font:</span>
	// 					<input
	// 						type="color"
	// 						value={fontColor}
	// 						onChange={(e) => {
	// 							setFontColor(e.target.value);
	// 							applyStyle({ color: e.target.value });
	// 						}}
	// 					/>
	// 				</label>
 
	// 				{/* Background Color Picker */}
	// 				<label className="flex items-center space-x-1">
	// 					<span>Bg:</span>
	// 					<input
	// 						type="color"
	// 						value={bgColor}
	// 						onChange={(e) => {
	// 							setBgColor(e.target.value);
	// 							applyStyle({ "background-color": e.target.value });
	// 						}}
	// 					/>
	// 				</label>
	// 			</div>
	// 		</>
	// 	);
	// }

	// function downloadHtml(editor) {
	// 	let html = "";
	// 	editor.getEditorState().read(() => {
	// 		html = $generateHtmlFromNodes(editor);
	// 	});
	// 	const blob = new Blob(
	// 		[ "<!doctype html><meta charset=utf-8>" + html ],
	// 		{ type: "text/html;charset=utf-8" }
	// 	);
	// 	saveAs(blob, "document.html");
	// }

	// async function downloadDocxFromHtml(editor) {
	// 	const { $generateHtmlFromNodes } = await import("@lexical/html");
	// 	const { default: HTMLtoDOCX } = await import("html-to-docx"); // HTML → DOCX

	// 	let html = "";
	// 	editor.getEditorState().read(() => {
	// 		html = $generateHtmlFromNodes(editor);
	// 	});

	// 	const wrapped = `<div style="white-space: pre-wrap">${html}</div>`;
	// 	const buf = await HTMLtoDOCX(wrapped, null, {
	// 		css: "table{border-collapse:collapse}td,th{border:1px solid #000;padding:4px} img{max-width:600px}"
	// 	});

	// 	saveAs(new Blob([buf], {
	// 		type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
	// 	}), "document.docx");
	// }

	return (
		<LexicalComposer initialConfig={lexicalEditorConfig}>
			<LexicalEditorTopBar onDownloadDocx={handleDownloadDocx} />
			<Divider />
			{/* <ColorToolbar/> */}
			{/* <div className="toolbar flex items-center space-x-4 p-2 border-b">
				<ColorPlugin />
			</div> */}
			<Box sx={{ position: "relative", background: "white" }}>
				<RichTextPlugin
					contentEditable={<MuiContentEditable />}
					placeholder={<Box sx={placeHolderSx}>Enter some text...</Box>}
					ErrorBoundary={LexicalErrorBoundary}
				/>
				<OnChangePlugin onChange={onChange} />
				<HistoryPlugin />
				{/* <TreeViewPlugin /> */}
				<ListPlugin />
				<LinkPlugin />
				<ImagesPlugin captionsEnabled={false} />
				<FloatingTextFormatToolbarPlugin />
				<TablePlugin />
				<MyCustomAutoFocusPlugin />
			</Box>
		</LexicalComposer>
	);
}

function MyCustomAutoFocusPlugin() {
	const [editor] = useLexicalComposerContext();

	useEffect(() => {
		editor.focus();
	}, [editor]);

	return null;
}

export default LexicalEditorWrapper;


// import { $getRoot, $getSelection, $isRangeSelection } from "lexical";
// import { useEffect } from "react";
// import { LexicalComposer } from "@lexical/react/LexicalComposer";
// import { HistoryPlugin } from "@lexical/react/LexicalHistoryPlugin";
// import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
// import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
// import { MuiContentEditable, placeHolderSx } from "./styles";
// import { Box, Divider } from "@mui/material";
// import { lexicalEditorConfig } from "../../config/lexicalEditorConfig";
// import LexicalEditorTopBar from "../LexicalEditorTopBar";
// import { ListPlugin } from "@lexical/react/LexicalListPlugin";
// import { LinkPlugin } from "@lexical/react/LexicalLinkPlugin";
// import ImagesPlugin from "../CustomPlugins/ImagePlugin";
// import FloatingTextFormatToolbarPlugin from "../CustomPlugins/FloatingTextFormatPlugin";
// import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
// import { TablePlugin } from "@lexical/react/LexicalTablePlugin";
// import { $generateHtmlFromNodes } from "@lexical/html";
// import { saveAs } from "file-saver";
// import { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell, BorderStyle } from "docx";

// // Child component to handle editor logic
// function EditorContent({ onDownloadDocx }) {
//   const [editor] = useLexicalComposerContext();

//   // Function to handle DOCX download from HTML
//   async function downloadDocxFromHtml() {
//     try {
//       let html = "";
//       editor.getEditorState().read(() => {
//         html = $generateHtmlFromNodes(editor);
//       });

//       // Parse HTML to create DOCX content
//       const parser = new DOMParser();
//       const doc = parser.parseFromString(html, "text/html");
//       const elements = doc.body.children;

//       const docxChildren = Array.from(elements).map((element) => {
//         if (element.tagName === "P") {
//           return new Paragraph({
//             children: [new TextRun(element.textContent)],
//             spacing: { after: 240 }, // 12pt spacing after paragraph
//           });
//         } else if (element.tagName === "TABLE") {
//           const rows = Array.from(element.querySelectorAll("tr")).map((row) => {
//             const cells = Array.from(row.querySelectorAll("td, th")).map(
//               (cell) =>
//                 new TableCell({
//                   children: [new Paragraph(cell.textContent)],
//                   borders: {
//                     top: { style: BorderStyle.SINGLE, size: 1 },
//                     bottom: { style: BorderStyle.SINGLE, size: 1 },
//                     left: { style: BorderStyle.SINGLE, size: 1 },
//                     right: { style: BorderStyle.SINGLE, size: 1 },
//                   },
//                 })
//             );
//             return new TableRow({ children: cells });
//           });
//           return new Table({
//             rows,
//             width: { size: 100, type: "pct" },
//           });
//         } else if (element.tagName.match(/^H[1-3]$/)) {
//           return new Paragraph({
//             children: [new TextRun(element.textContent)],
//             heading: `Heading${element.tagName[1]}`,
//             spacing: { before: 240, after: 240 },
//           });
//         } else if (element.tagName === "A") {
//           return new Paragraph({
//             children: [
//               new TextRun({
//                 text: element.textContent,
//                 color: "0000FF",
//                 underline: {},
//               }),
//             ],
//           });
//         }
//         return null;
//       }).filter(Boolean);

//       // Create DOCX document
//       const docx = new Document({
//         sections: [
//           {
//             properties: {},
//             children: docxChildren,
//           },
//         ],
//       });

//       // Generate and save the DOCX file
//       const blob = await Packer.toBlob(docx);
//       saveAs(blob, "document.docx");
//     } catch (error) {
//       console.error("Error generating DOCX:", error);
//       alert("Failed to generate DOCX file. Please try again.");
//     }
//   }

//   return (
//     <>
//       <LexicalEditorTopBar onDownloadDocx={downloadDocxFromHtml} />
//       <Divider />
//       <Box sx={{ position: "relative", background: "white" }}>
//         <RichTextPlugin
//           contentEditable={<MuiContentEditable />}
//           placeholder={<Box sx={placeHolderSx}>Enter some text...</Box>}
//           ErrorBoundary={LexicalErrorBoundary}
//         />
//         <HistoryPlugin />
//         <ListPlugin />
//         <LinkPlugin />
//         <ImagesPlugin captionsEnabled={false} />
//         <FloatingTextFormatToolbarPlugin />
//         <TablePlugin />
//         <MyCustomAutoFocusPlugin />
//       </Box>
//     </>
//   );
// }

// function MyCustomAutoFocusPlugin() {
//   const [editor] = useLexicalComposerContext();

//   useEffect(() => {
//     editor.focus();
//   }, [editor]);

//   return null;
// }

// function LexicalEditorWrapper(props) {
//   return (
//     <LexicalComposer initialConfig={lexicalEditorConfig}>
//       <EditorContent />
//     </LexicalComposer>
//   );
// }

// export default LexicalEditorWrapper;

// import { $getRoot, $getSelection, $isRangeSelection, $isTextNode, $isElementNode } from "lexical";
// import { useEffect } from "react";
// import { LexicalComposer } from "@lexical/react/LexicalComposer";
// import { HistoryPlugin } from "@lexical/react/LexicalHistoryPlugin";
// import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
// import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
// import { MuiContentEditable, placeHolderSx } from "./styles";
// import { Box, Divider } from "@mui/material";
// import { lexicalEditorConfig } from "../../config/lexicalEditorConfig";
// import LexicalEditorTopBar from "../LexicalEditorTopBar";
// import { ListPlugin } from "@lexical/react/LexicalListPlugin";
// import { LinkPlugin } from "@lexical/react/LexicalLinkPlugin";
// import ImagesPlugin from "../CustomPlugins/ImagePlugin";
// import FloatingTextFormatToolbarPlugin from "../CustomPlugins/FloatingTextFormatPlugin";
// import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
// import { TablePlugin } from "@lexical/react/LexicalTablePlugin";
// import { saveAs } from "file-saver";
// import { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell, BorderStyle, AlignmentType, HeadingLevel } from "docx";

// // Child component to handle editor logic
// function EditorContent({ onDownloadDocx }) {
//   const [editor] = useLexicalComposerContext();

//   // Function to handle DOCX download with styles
//   async function downloadDocxFromHtml() {
//     try {
//       const docxChildren = [];

//       // Process Lexical nodes to preserve styles
//       editor.getEditorState().read(() => {
//         const root = $getRoot();
//         const children = root.getChildren();

//         children.forEach((node) => {
//           if ($isElementNode(node)) {
//             if (node.getType() === "paragraph") {
//               const paragraphChildren = node.getChildren().map((child) => {
//                 if ($isTextNode(child)) {
//                   return new TextRun({
//                     text: child.getTextContent(),
//                     bold: child.hasFormat("bold"),
//                     italics: child.hasFormat("italic"),
//                     underline: child.hasFormat("underline") ? {} : undefined,
//                     font: { name: "Arial" },
//                     size: 24, // 12pt (in half-points)
//                   });
//                 }
//                 return null;
//               }).filter(Boolean);

//               docxChildren.push(
//                 new Paragraph({
//                   children: paragraphChildren,
//                   spacing: { after: 240 },
//                   alignment: node.getFormat() === "center" ? AlignmentType.CENTER : 
//                             node.getFormat() === "right" ? AlignmentType.RIGHT : 
//                             AlignmentType.LEFT,
//                 })
//               );
//             } else if (node.getType() === "heading") {
//               const headingLevel = node.getTag() === "h1" ? HeadingLevel.HEADING_1 :
//                                   node.getTag() === "h2" ? HeadingLevel.HEADING_2 :
//                                   HeadingLevel.HEADING_3;
//               const headingChildren = node.getChildren().map((child) => {
//                 if ($isTextNode(child)) {
//                   return new TextRun({
//                     text: child.getTextContent(),
//                     bold: child.hasFormat("bold"),
//                     italics: child.hasFormat("italic"),
//                     underline: child.hasFormat("underline") ? {} : undefined,
//                     font: { name: "Arial" },
//                     size: 24, // 12pt (in half-points)
//                   });
//                 }
//                 return null;
//               }).filter(Boolean);

//               docxChildren.push(
//                 new Paragraph({
//                   children: headingChildren,
//                   heading: headingLevel,
//                   spacing: { before: 240, after: 240 },
//                 })
//               );
//             } else if (node.getType() === "table") {
//               const rows = node.getChildren().map((rowNode) => {
//                 const cells = rowNode.getChildren().map((cellNode) => {
//                   const cellChildren = cellNode.getChildren().map((child) => {
//                     if ($isTextNode(child)) {
//                       return new Paragraph({
//                         children: [
//                           new TextRun({
//                             text: child.getTextContent(),
//                             bold: child.hasFormat("bold"),
//                             italics: child.hasFormat("italic"),
//                             underline: child.hasFormat("underline") ? {} : undefined,
//                             font: { name: "Arial" },
//                             size: 24,
//                           }),
//                         ],
//                       });
//                     }
//                     return null;
//                   }).filter(Boolean);

//                   return new TableCell({
//                     children: cellChildren,
//                     borders: {
//                       top: { style: BorderStyle.SINGLE, size: 1 },
//                       bottom: { style: BorderStyle.SINGLE, size: 1 },
//                       left: { style: BorderStyle.SINGLE, size: 1 },
//                       right: { style: BorderStyle.SINGLE, size: 1 },
//                     },
//                   });
//                 });
//                 return new TableRow({ children: cells });
//               });

//               docxChildren.push(
//                 new Table({
//                   rows,
//                   width: { size: 100, type: "pct" },
//                 })
//               );
//             } else if (node.getType() === "link") {
//               const linkChildren = node.getChildren().map((child) => {
//                 if ($isTextNode(child)) {
//                   return new TextRun({
//                     text: child.getTextContent(),
//                     bold: child.hasFormat("bold"),
//                     italics: child.hasFormat("italic"),
//                     underline: { type: "single" },
//                     color: "0000FF",
//                     font: { name: "Arial" },
//                     size: 24,
//                   });
//                 }
//                 return null;
//               }).filter(Boolean);

//               docxChildren.push(
//                 new Paragraph({
//                   children: linkChildren,
//                   spacing: { after: 240 },
//                 })
//               );
//             }
//           }
//         });
//       });

//       // Create DOCX document
//       const docx = new Document({
//         sections: [
//           {
//             properties: {
//               page: {
//                 margin: { top: 720, bottom: 720, left: 720, right: 720 },
//               },
//             },
//             children: docxChildren,
//           },
//         ],
//       });

//       // Generate and save the DOCX file
//       const blob = await Packer.toBlob(docx);
//       saveAs(blob, "document.docx");
//     } catch (error) {
//       console.error("Error generating DOCX:", error);
//       alert("Failed to generate DOCX file. Please try again.");
//     }
//   }

//   return (
//     <>
//       <LexicalEditorTopBar onDownloadDocx={downloadDocxFromHtml} />
//       <Divider />
//       <Box sx={{ position: "relative", background: "white" }}>
//         <RichTextPlugin
//           contentEditable={<MuiContentEditable />}
//           placeholder={<Box sx={placeHolderSx}>Enter some text...</Box>}
//           ErrorBoundary={LexicalErrorBoundary}
//         />
//         <HistoryPlugin />
//         <ListPlugin />
//         <LinkPlugin />
//         <ImagesPlugin captionsEnabled={false} />
//         <FloatingTextFormatToolbarPlugin />
//         <TablePlugin />
//         <MyCustomAutoFocusPlugin />
//       </Box>
//     </>
//   );
// }

// function MyCustomAutoFocusPlugin() {
//   const [editor] = useLexicalComposerContext();

//   useEffect(() => {
//     editor.focus();
//   }, [editor]);

//   return null;
// }

// function LexicalEditorWrapper(props) {
//   return (
//     <LexicalComposer initialConfig={lexicalEditorConfig}>
//       <EditorContent />
//     </LexicalComposer>
//   );
// }

// export default LexicalEditorWrapper;

// import { $getRoot, $isElementNode, $isTextNode } from "lexical";
// import { useEffect } from "react";
// import { LexicalComposer } from "@lexical/react/LexicalComposer";
// import { HistoryPlugin } from "@lexical/react/LexicalHistoryPlugin";
// import { RichTextPlugin } from "@lexical/react/LexicalRichTextPlugin";
// import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
// import { MuiContentEditable, placeHolderSx } from "./styles";
// import { Box, Divider } from "@mui/material";
// import { lexicalEditorConfig } from "../../config/lexicalEditorConfig";
// import LexicalEditorTopBar from "../LexicalEditorTopBar";
// import { ListPlugin } from "@lexical/react/LexicalListPlugin";
// import { LinkPlugin } from "@lexical/react/LexicalLinkPlugin";
// import ImagesPlugin from "../CustomPlugins/ImagePlugin";
// import FloatingTextFormatToolbarPlugin from "../CustomPlugins/FloatingTextFormatPlugin";
// import { LexicalErrorBoundary } from "@lexical/react/LexicalErrorBoundary";
// import { TablePlugin } from "@lexical/react/LexicalTablePlugin";
// import { saveAs } from "file-saver";
// import {
//   Document,
//   Packer,
//   Paragraph,
//   TextRun,
//   Table,
//   TableRow,
//   TableCell,
//   BorderStyle,
//   AlignmentType,
//   HeadingLevel,
//   ExternalHyperlink,
//   ShadingType,
//   WidthType,
// } from "docx";

// // Child component to handle editor logic
// function EditorContent() {
//   const [editor] = useLexicalComposerContext();

//   // Function to handle DOCX download with styles
//   async function downloadDocx() {
//     try {
//       const docxChildren = [];

//       // Process Lexical nodes to preserve styles
//       editor.getEditorState().read(() => {
//       const root = $getRoot();
//         const children = root.getChildren();

//         children.forEach((node) => {
//           if ($isElementNode(node)) {
//             const nodeType = node.getType();
            
//             // Handle paragraphs
//             if (nodeType === "paragraph") {
//               const paragraphChildren = processTextNodes(node.getChildren());
              
//               if (paragraphChildren.length > 0) {
//                 docxChildren.push(
//                   new Paragraph({
//                     children: paragraphChildren,
//                     spacing: { after: 240 },
//                     alignment: getAlignment(node.getFormatType()),
//                   })
//                 );
//               }
//             } 
//             // Handle headings
//             else if (nodeType === "heading") {
//               const headingLevel = getHeadingLevel(node.getTag());
//               const headingChildren = processTextNodes(node.getChildren());
              
//               if (headingChildren.length > 0) {
//                 docxChildren.push(
//                   new Paragraph({
//                     children: headingChildren,
//                     heading: headingLevel,
//                     spacing: { before: 240, after: 240 },
//                     alignment: getAlignment(node.getFormatType()),
//                   })
//                 );
//               }
//             } 
//             // Handle quotes
//             else if (nodeType === "quote") {
//               const quoteChildren = processTextNodes(node.getChildren());
              
//               if (quoteChildren.length > 0) {
//                 docxChildren.push(
//                   new Paragraph({
//                     children: [
//                       new TextRun({ text: "“", bold: true }),
//                       ...quoteChildren,
//                       new TextRun({ text: "”", bold: true }),
//                     ],
//                     spacing: { after: 240 },
//                     alignment: getAlignment(node.getFormatType()),
//                   })
//                 );
//               }
//             } 
//             // Handle lists
//             else if (nodeType === "list") {
//               const listItems = node.getChildren();
//               const isOrdered = node.getTag() === "ol";
              
//               listItems.forEach((listItem, index) => {
//                 const listItemChildren = processTextNodes(listItem.getChildren());
//                 const bulletText = isOrdered ? `${index + 1}. ` : "• ";
                
//                 if (listItemChildren.length > 0) {
//                   docxChildren.push(
//                     new Paragraph({
//                       children: [
//                         new TextRun({ text: bulletText, bold: true }),
//                         ...listItemChildren,
//                       ],
//                       spacing: { after: 120 },
//                       alignment: getAlignment(node.getFormatType()),
//                     })
//                   );
//                 }
//               });
//             } 
//             // Handle tables
//             else if (nodeType === "table") {
//               const rows = node.getChildren().map((rowNode) => {
//                 const cells = rowNode.getChildren().map((cellNode) => {
//                   // Process all content within the cell (could be multiple paragraphs)
//                   const cellContent = [];
                  
//                   cellNode.getChildren().forEach((cellChild) => {
//                     if ($isElementNode(cellChild) && cellChild.getType() === "paragraph") {
//                       const paragraphChildren = processTextNodes(cellChild.getChildren());
                      
//                       if (paragraphChildren.length > 0) {
//                         cellContent.push(
//                           new Paragraph({
//                             children: paragraphChildren,
//                             spacing: { after: 80 },
//                           })
//                         );
//                       }
//           } else {
//                       // Handle text nodes directly in table cells
//                       const textChildren = processTextNodes([cellChild]);
//                       if (textChildren.length > 0) {
//                         cellContent.push(
//                           new Paragraph({
//                             children: textChildren,
//                             spacing: { after: 80 },
//                           })
//                         );
//                       }
//                     }
//                   });
                  
//                   // If no content, add an empty paragraph to prevent empty cells
//                   if (cellContent.length === 0) {
//                     cellContent.push(new Paragraph({ children: [new TextRun({ text: " " })] }));
//                   }
                  
//                   return new TableCell({
//                     children: cellContent,
//                     margins: { top: 100, bottom: 100, left: 100, right: 100 },
//                     borders: {
//                       top: { style: BorderStyle.SINGLE, size: 1 },
//                       bottom: { style: BorderStyle.SINGLE, size: 1 },
//                       left: { style: BorderStyle.SINGLE, size: 1 },
//                       right: { style: BorderStyle.SINGLE, size: 1 },
//                     },
//                   });
//                 });
                
//                 return new TableRow({ children: cells });
//               });
              
//               // Only add table if it has rows and cells
//               if (rows.length > 0 && rows[0].options.children.length > 0) {
//                 docxChildren.push(
//           new Table({
//             rows,
//                     width: { size: 100, type: WidthType.PERCENTAGE },
//                     layout: "autofit",
//                   })
//                 );
//               }
//             } 
//             // Handle links
//             else if (nodeType === "link") {
//               const url = node.getURL();
//               const linkChildren = processTextNodes(node.getChildren(), true);
              
//               if (linkChildren.length > 0) {
//                 docxChildren.push(
//                   new Paragraph({
//                     children: [
//                       new ExternalHyperlink({
//                         children: linkChildren,
//                         link: url,
//                       }),
//                     ],
//                     spacing: { after: 240 },
//                   })
//                 );
//               }
//             }
//           }
//         });
//       });

//       // If no content was processed, add a default paragraph
//       if (docxChildren.length === 0) {
//         docxChildren.push(
//           new Paragraph({
//             children: [new TextRun({ text: " " })],
//           })
//         );
//       }

//       // Create DOCX document
//       const docx = new Document({
//       sections: [
//         {
//             properties: {
//               page: {
//                 margin: { top: 720, right: 720, bottom: 720, left: 720 }, // 0.5 inch margins
//               },
//             },
//             children: docxChildren,
//         },
//       ],
//     });

//       // Generate and save the DOCX file
//       const blob = await Packer.toBlob(docx);
//     saveAs(blob, "document.docx");
//     } catch (error) {
//       console.error("Error generating DOCX:", error);
//       alert("Failed to generate DOCX file. Please try again.");
//     }
//   }

//   // Helper function to process text nodes with formatting
//   function processTextNodes(nodes, isLink = false) {
//     const textRuns = [];
    
//     nodes.forEach((node) => {
//       if ($isTextNode(node)) {
//         const textContent = node.getTextContent();
        
//         // Only add text runs for non-empty text
//         if (textContent.trim().length > 0) {
//           const style = node.getStyle();
//           const styleObj = parseStyleString(style);
          
//           textRuns.push(
//             new TextRun({
//               text: textContent,
//               bold: node.hasFormat("bold"),
//               italics: node.hasFormat("italic"),
//               underline: node.hasFormat("underline") ? {} : undefined,
//               strike: node.hasFormat("strikethrough") ? {} : undefined,
//               color: isLink ? "0000FF" : (styleObj.color || undefined),
//               font: { name: styleObj["font-family"] || "Arial" },
//               size: styleObj["font-size"] ? parseInt(styleObj["font-size"]) * 2 : 24, // Convert px to half-points
//               shading: styleObj["background-color"] ? {
//                 type: ShadingType.CLEAR,
//                 color: "auto",
//                 fill: styleObj["background-color"],
//               } : undefined,
//             })
//           );
//         }
//       } else if ($isElementNode(node) && node.getType() === "linebreak") {
//         textRuns.push(new TextRun({ break: 1 }));
//       }
//     });
    
//     return textRuns;
//   }

//   // Helper function to parse CSS style string to object
//   function parseStyleString(styleString) {
//     const styleObj = {};
//     if (!styleString) return styleObj;
    
//     styleString.split(";").forEach((declaration) => {
//       const [property, value] = declaration.split(":").map(part => part.trim());
//       if (property && value) {
//         styleObj[property] = value;
//       }
//     });
    
//     return styleObj;
//   }

//   // Helper function to get alignment
//   function getAlignment(format) {
//     switch (format) {
//       case "center":
//         return AlignmentType.CENTER;
//       case "right":
//         return AlignmentType.RIGHT;
//       case "justify":
//         return AlignmentType.JUSTIFIED;
//       default:
//         return AlignmentType.LEFT;
//     }
//   }

//   // Helper function to get heading level
//   function getHeadingLevel(tag) {
//     switch (tag) {
//       case "h1":
//         return HeadingLevel.HEADING_1;
//       case "h2":
//         return HeadingLevel.HEADING_2;
//       case "h3":
//         return HeadingLevel.HEADING_3;
//       case "h4":
//         return HeadingLevel.HEADING_4;
//       case "h5":
//         return HeadingLevel.HEADING_5;
//       case "h6":
//         return HeadingLevel.HEADING_6;
//       default:
//         return HeadingLevel.HEADING_1;
//     }
// }

//   return (
//     <>
//       <LexicalEditorTopBar onDownloadDocx={downloadDocx} />
//       <Divider />
//       <Box sx={{ position: "relative", background: "white" }}>
//         <RichTextPlugin
//           contentEditable={<MuiContentEditable />}
//           placeholder={<Box sx={placeHolderSx}>Enter some text...</Box>}
//           ErrorBoundary={LexicalErrorBoundary}
//         />
//         <HistoryPlugin />
//         <ListPlugin />
//         <LinkPlugin />
//         <ImagesPlugin captionsEnabled={false} />
//         <FloatingTextFormatToolbarPlugin />
//         <TablePlugin />
//         <MyCustomAutoFocusPlugin />
//       </Box>
//     </>
//   );
// }

// function MyCustomAutoFocusPlugin() {
//   const [editor] = useLexicalComposerContext();

//   useEffect(() => {
//     editor.focus();
//   }, [editor]);

//   return null;
// }

// function LexicalEditorWrapper(props) {
//   return (
//     <LexicalComposer initialConfig={lexicalEditorConfig}>
//       <EditorContent />
//     </LexicalComposer>
//   );
// }

// export default LexicalEditorWrapper;